# Phase 2.2 - Static Departures Bugfix and Modal Coverage Implementation Plan

**Type:** Custom Plan (Bug Fix)
**Context:** Fix missing departures for non-train stops and restore full multi-modal coverage
**Complexity:** Medium
**Estimated Duration:** 4-6 hours

---

## Problem Statement

Fix missing departures for non-train stops (sample sids 29443/29444 return empty results) and restore full multi-modal coverage (bus, ferry, light rail) broken after Phase 2.1. Root cause: incomplete or inconsistent sid↔stop_id mapping between iOS SQLite dict_stop and backend queries. Backend departures API expects GTFS stop_id (string) but mapping may be incomplete, causing pattern_stops lookup failures. Current state: search only surfaces train stations, iOS missing validation that all 4687 routes across 7 NSW route types are reachable end-to-end.

---

## Affected Systems

### System: Backend departures API (realtime_service.py)
- **Current state:** Expects GTFS stop_id string, queries pattern_stops table, merges Redis GTFS-RT
- **Gap:** Fails if client sends integer sid instead of stop_id; no validation/mapping layer; logs show no_static_departures for sids 29443/29444
- **Files affected:**
  - `backend/app/services/realtime_service.py`
  - `backend/app/api/v1/stops.py`

### System: iOS SQLite dict_stop mapping
- **Current state:** dict_stop table generated by ios_db_generator.py, maps sid↔stop_id, used in Stop.getStopID()
- **Gap:** May be incomplete or stale; DeparturesView uses stop.getStopID() but fallback unclear; no E2E validation that all stops have dict_stop entries
- **Files affected:**
  - `backend/app/services/ios_db_generator.py`
  - `SydneyTransit/SydneyTransit/Data/Models/Stop.swift`

### System: iOS Stop.primaryRouteType and transport icons
- **Current state:** Queries DB for most frequent route_type, maps to SF Symbol icons; supports standard GTFS 0-7 + NSW 401/700/712/714/900
- **Gap:** Icons implemented but no validation that all 4687 routes across 7 types are reachable; search may filter out non-train stops if primaryRouteType fails
- **Files affected:**
  - `SydneyTransit/SydneyTransit/Data/Models/Stop.swift` (lines 102-128)
  - `SydneyTransit/SydneyTransit/Features/Search/SearchView.swift`

### System: Backend search endpoint (stops.py)
- **Current state:** Uses PostgreSQL trigram similarity on stop_name, no route_type filtering
- **Gap:** Should return all modalities but client may filter results if Stop.primaryRouteType returns nil; no logging of modality distribution in search results
- **Files affected:**
  - `backend/app/api/v1/stops.py` (lines 77-126)

---

## Key Technical Decisions

### 1. Standardize on GTFS stop_id at API boundary; iOS always sends stop_id from dict_stop
- **Rationale:** Backend pattern_stops table uses stop_id (text), not sid (int); consistent with GTFS spec; prevents ambiguity
- **Reference:** `backend/app/services/realtime_service.py:164` (WHERE ps.stop_id = '{stop_id}')
- **Critical constraint:** DeparturesView.swift:139 must use stop.getStopID() and validate non-nil before API call

### 2. Ensure dict_stop table 100% complete in both Supabase and iOS SQLite
- **Rationale:** ios_db_generator.py builds dict_stop from Supabase stops table; missing entries break departures lookup
- **Reference:** `ios_db_generator.py:265-270`, `Stop.swift:68-74`
- **Critical constraint:** Every stop in stops table must have dict_stop entry; GTFS ingestion must populate Supabase dict_stop before iOS export

### 3. Add backend validation/logging for stop_id in departures endpoint
- **Rationale:** Current code logs no_static_departures but doesn't distinguish stop_not_found vs no_trips; need diagnostic clarity
- **Reference:** `stops.py:211-223` (stop_check validation exists), `realtime_service.py:176` (no_static_departures log)
- **Critical constraint:** Log stop_id type, dict_stop lookup attempts, and pattern_stops row count for debugging

### 4. Validate all 7 NSW route types (2,4,401,700,712,714,900) are searchable and reachable
- **Rationale:** Phase 2.1 fixes confirmed all 4687 routes in DB; icons exist in Stop.swift; need E2E test to prove reachability
- **Reference:** `specs/phase-2-1-fixes-plan.md:46-50` (route type distribution), `Stop.swift:102-113` (icon mapping)
- **Critical constraint:** E2E test must search for bus/ferry/light rail stop, verify icon appears, tap for departures, confirm results

---

## Implementation Checkpoints

### Checkpoint 1: Verify dict_stop Completeness in Supabase and iOS SQLite

**Goal:** Confirm every stop has sid↔stop_id mapping; no missing entries causing lookup failures

**Backend Work:**
- Query Supabase to validate dict_stop completeness:
  ```sql
  -- Expected: same count
  SELECT COUNT(*) AS stops_count FROM stops;
  SELECT COUNT(*) AS dict_stop_count FROM dict_stop;
  ```
- Check sample stops 29443/29444 exist in dict_stop:
  ```sql
  SELECT sid, stop_id FROM dict_stop WHERE sid IN (29443, 29444);
  ```
- Add validation logging to ios_db_generator.py:
  - Log dict_stop row count after building dictionaries
  - Validate stops count == dict_stop count
  - Raise error if mismatch detected
- If counts don't match, regenerate dict_stop:
  ```sql
  TRUNCATE dict_stop;
  INSERT INTO dict_stop (sid, stop_id)
  SELECT sid, stop_id FROM stops WHERE stop_id IS NOT NULL;
  ```

**iOS Work:**
- Query iOS SQLite gtfs.db to validate dict_stop completeness:
  ```bash
  # In iOS simulator or device, use GRDB query
  sqlite3 gtfs.db "SELECT COUNT(*) FROM stops;"
  sqlite3 gtfs.db "SELECT COUNT(*) FROM dict_stop;"
  ```
- Check sample sids 29443/29444:
  ```bash
  sqlite3 gtfs.db "SELECT sid, stop_id FROM dict_stop WHERE sid IN (29443, 29444);"
  ```
- Add error handling in DeparturesView.swift if getStopID() returns nil:
  ```swift
  guard let stopID = stop.getStopID() else {
      self.errorMessage = "Stop ID mapping missing for \(stop.name)"
      logger.error("dict_stop_missing", sid: stop.sid)
      return
  }
  ```

**Design Constraints:**
- Follow dictionary encoding pattern from DEVELOPMENT_STANDARDS.md (iOS data layer)
- Use FastAPI RPC (`exec_raw_sql`) for Supabase validation queries (pattern: `stops.py:172`)
- Log structured events with key-value pairs (pattern: `realtime_service.py:176`)

**Validation:**
```bash
# Backend check (use Supabase MCP or direct SQL)
curl -X POST http://localhost:8000/api/v1/internal/validate-dict-stop

# Expected output:
# {"stops_count": 12345, "dict_stop_count": 12345, "missing_entries": 0}

# Test sample stops from dict_stop
curl 'http://localhost:8000/api/v1/stops/200060/departures' # Train stop (known working)
curl 'http://localhost:8000/api/v1/stops/[stop_id_29443]/departures' # Should return results
curl 'http://localhost:8000/api/v1/stops/[stop_id_29444]/departures' # Should return results
```

**References:**
- Pattern: Dictionary encoding - `ios_db_generator.py:218-235`, `Stop.swift:68-74`
- Architecture: `DATA_ARCHITECTURE.md` (pattern model, dict tables)

---

### Checkpoint 2: Standardize Departures API Identifier Handling

**Goal:** Backend handles stop_id consistently; graceful error if invalid ID; clear logging for debugging

**Backend Work:**
- Add enhanced logging in `realtime_service.py:get_static_departures()`:
  ```python
  # Line ~109, before querying pattern_stops
  logger.info(
      "departures_lookup_start",
      stop_id=stop_id,
      stop_id_type=type(stop_id).__name__,
      route_type=route_type
  )
  ```
- After pattern_stops query (line ~176), add diagnostic logging:
  ```python
  if not static_departures:
      # Check if stop exists vs no trips
      stop_exists = supabase.table("stops").select("stop_id").eq("stop_id", stop_id).execute()
      pattern_count = supabase.rpc("exec_raw_sql", {
          "query": f"SELECT COUNT(*) FROM pattern_stops WHERE stop_id = '{stop_id}'"
      }).execute()

      logger.warning(
          "no_static_departures",
          stop_id=stop_id,
          stop_exists=len(stop_exists.data) > 0,
          pattern_stops_count=pattern_count.data[0]["count"] if pattern_count.data else 0,
          route_type_filter=route_type
      )
  ```
- In `stops.py:get_departures()` endpoint (line ~211), validate stop_id format:
  ```python
  # After stop_check validation (line 223)
  if not stop_data:
      raise HTTPException(
          status_code=404,
          detail={
              "error": {
                  "code": "STOP_NOT_FOUND",
                  "message": f"Stop with ID '{stop_id}' does not exist in database",
                  "details": {"stop_id": stop_id}
              }
          }
      )
  ```

**iOS Work:**
- Verify DeparturesView.swift:139 uses `stop.getStopID()` (already implemented)
- Add diagnostic logging in DeparturesView before API call:
  ```swift
  // Line ~145, before realtime_service.fetchDepartures()
  let stopID = stop.getStopID()
  logger.info("departures_request", sid: stop.sid, stop_id: stopID ?? "nil")

  guard let stopID = stopID else {
      self.errorMessage = "Unable to fetch departures: stop ID mapping missing"
      logger.error("departures_missing_stop_id", sid: stop.sid, stop_name: stop.name)
      return
  }
  ```
- Enhance error handling for 404 responses:
  ```swift
  // Line ~154, update errorMessage handling
  if let apiError = error as? APIError, apiError.code == "STOP_NOT_FOUND" {
      self.errorMessage = "This stop is not in our database"
  } else {
      self.errorMessage = "Failed to load departures: \(error.localizedDescription)"
  }
  ```

**Design Constraints:**
- Use structured logging (JSON key-value pairs) per DEVELOPMENT_STANDARDS.md Section 3
- Never log PII (user_id if added later, but stop_id is safe)
- Backend must distinguish stop_not_found vs no_trips_scheduled for debugging
- iOS must handle nil getStopID() gracefully (don't crash or show blank screen)

**Validation:**
```bash
# Test with sample stops
curl 'http://localhost:8000/api/v1/stops/invalid_stop_id/departures'
# Expected: 404 STOP_NOT_FOUND error

# Check backend logs for diagnostic info
tail -f backend/logs/app.log | grep departures_lookup_start
tail -f backend/logs/app.log | grep no_static_departures

# iOS logs (Xcode console)
# Expected: "departures_request sid=29443 stop_id=<stop_id_value>"
# Expected: "departures_missing_stop_id" if getStopID() returns nil
```

**References:**
- Pattern: Structured logging - `realtime_service.py:176`
- Pattern: FastAPI error responses - `stops.py:211-223`
- Architecture: `BACKEND_SPECIFICATION.md` Section 4 (error handling)

---

### Checkpoint 3: Validate Multi-Modal Coverage (All 7 Route Types)

**Goal:** Confirm search returns bus/ferry/light rail stops; icons display correctly; departures work for all 7 NSW route types

**Backend Work:**
- Add route_type distribution logging to search endpoint (`stops.py:77-126`):
  ```python
  # After stop results returned (line ~120)
  if results:
      route_type_distribution = {}
      for stop in results:
          # Query route_type for this stop
          route_types = supabase.rpc("exec_raw_sql", {
              "query": f"""
                  SELECT DISTINCT r.route_type
                  FROM patterns p
                  JOIN routes r ON p.route_id = r.route_id
                  JOIN pattern_stops ps ON p.pattern_id = ps.pattern_id
                  WHERE ps.stop_id = '{stop["stop_id"]}'
              """
          }).execute()

          for rt in route_types.data:
              route_type = rt.get("route_type")
              route_type_distribution[route_type] = route_type_distribution.get(route_type, 0) + 1

      logger.info(
          "search_results_modality",
          query=query,
          total_results=len(results),
          route_type_distribution=route_type_distribution
      )
  ```
- Verify pattern_stops includes all route types for sample stops:
  ```sql
  -- Check coverage for sample bus stop sid 29444
  SELECT r.route_type, COUNT(DISTINCT p.pattern_id) AS pattern_count
  FROM pattern_stops ps
  JOIN patterns p ON ps.pattern_id = p.pattern_id
  JOIN routes r ON p.route_id = r.route_id
  WHERE ps.stop_id = (SELECT stop_id FROM dict_stop WHERE sid = 29444)
  GROUP BY r.route_type;
  ```

**iOS Work:**
- Add logging in SearchView.swift after search results loaded:
  ```swift
  // Line ~108, after results populated
  let routeTypeCounts = Dictionary(grouping: results, by: { $0.primaryRouteType })
      .mapValues { $0.count }

  logger.info(
      "search_results_ios",
      query: searchText,
      total: results.count,
      route_types: routeTypeCounts.map { "\($0.key ?? "nil"):\($0.value)" }.joined(separator: ",")
  )
  ```
- Manual E2E test queries:
  ```
  Search: "bus" → Expect bus stops with bus.fill icon
  Search: "ferry" → Expect ferry stops with ferry.fill icon
  Search: "light rail" → Expect light rail stops with lightrail.fill icon
  Search: "29444" → Expect bus stop, tap → departures load
  ```
- Verify icon rendering for all route types in Stop.swift (lines 102-128):
  - Route type 2 (rail) → "tram.fill"
  - Route type 4 (ferry) → "ferry.fill"
  - Route type 401 (metro) → "cablecar.fill"
  - Route type 700 (bus) → "bus.fill"
  - Route type 712 (school bus) → "bus.fill"
  - Route type 714 (regional bus) → "bus.fill"
  - Route type 900 (light rail) → "lightrail.fill"

**Design Constraints:**
- Follow MVVM + async/await pattern (DEVELOPMENT_STANDARDS.md)
- Log primaryRouteType nil cases separately (indicates dict_route lookup failure)
- Search endpoint must return stops regardless of route_type (no filtering)
- iOS should display all search results (not filter by route type unless user requests)

**Validation:**
```bash
# Backend: Check route type distribution in search results
curl 'http://localhost:8000/api/v1/stops/search?query=bus'
# Check logs: search_results_modality with route_type_distribution

curl 'http://localhost:8000/api/v1/stops/search?query=ferry'
# Expected: results include ferry stops (route_type 4)

# iOS: Manual test in simulator
# 1. Search "bus" → Verify bus.fill icons appear
# 2. Search "ferry" → Verify ferry.fill icons appear
# 3. Search "light rail" → Verify lightrail.fill icons appear
# 4. Tap any non-train stop → Verify DeparturesView loads
# 5. Check Xcode console logs for search_results_ios and route_types distribution
```

**References:**
- Pattern: Stop.primaryRouteType - `Stop.swift:102-128`
- Architecture: `SYSTEM_OVERVIEW.md` Section 2 (multi-modal coverage)

---

### Checkpoint 4: Add E2E Tests and Regression Prevention

**Goal:** Automated tests prevent regression; cover all 7 route types with sample stops

**Backend Work:**
- Create pytest test file: `backend/tests/test_departures_multi_modal.py`:
  ```python
  import pytest
  from app.main import app
  from fastapi.testclient import client

  # Sample stops for each route type (populate from DB query)
  SAMPLE_STOPS = {
      "train": "200060",  # Circular Quay
      "metro": "<metro_stop_id>",
      "bus": "<bus_stop_id_from_29444>",
      "school_bus": "<school_bus_stop_id>",
      "regional_bus": "<regional_bus_stop_id>",
      "ferry": "<ferry_stop_id>",
      "light_rail": "<light_rail_stop_id>"
  }

  @pytest.mark.parametrize("route_type,stop_id", SAMPLE_STOPS.items())
  def test_departures_all_route_types(route_type, stop_id):
      """Test departures API returns results for all NSW route types"""
      response = client.get(f"/api/v1/stops/{stop_id}/departures")
      assert response.status_code == 200
      data = response.json()["data"]
      assert len(data) > 0, f"No departures for {route_type} stop {stop_id}"
      # Verify at least one departure has correct route_type
      departure_route_types = [d["route_type"] for d in data]
      assert len(departure_route_types) > 0

  def test_dict_stop_completeness():
      """Validate dict_stop has entry for every stop"""
      stops_count = supabase.table("stops").select("stop_id", count="exact").execute()
      dict_stop_count = supabase.table("dict_stop").select("sid", count="exact").execute()
      assert stops_count.count == dict_stop_count.count, \
          f"dict_stop incomplete: {stops_count.count} stops, {dict_stop_count.count} dict_stop entries"
  ```
- Run pytest to validate:
  ```bash
  cd backend && source venv/bin/activate
  pytest tests/test_departures_multi_modal.py -v
  ```

**iOS Work:**
- Create manual E2E test checklist: `.workflow-logs/custom/phase-2-2-static-departures-bugfix-modal-coverage/ios-e2e-test-checklist.md`:
  ```markdown
  # iOS E2E Test Checklist: Multi-Modal Coverage

  ## Test Environment
  - [ ] Backend running (http://localhost:8000/health returns 200)
  - [ ] iOS simulator launched (iPhone 15 Pro, iOS 17+)
  - [ ] gtfs.db bundled with app (check file size ~15-20MB)

  ## Route Type Coverage Tests

  ### Train (route_type 2)
  - [ ] Search "Central Station"
  - [ ] Verify tram.fill icon appears
  - [ ] Tap stop → DeparturesView loads
  - [ ] Verify departures list shows train routes

  ### Metro (route_type 401)
  - [ ] Search "Barangaroo" or metro station
  - [ ] Verify cablecar.fill icon appears
  - [ ] Tap stop → DeparturesView loads
  - [ ] Verify departures list shows metro routes

  ### Bus (route_type 700)
  - [ ] Search "bus 29444" or "bus stop"
  - [ ] Verify bus.fill icon appears
  - [ ] Tap stop → DeparturesView loads
  - [ ] Verify departures list shows bus routes (NOT empty)

  ### School Bus (route_type 712)
  - [ ] Search school bus stop (query DB for sample)
  - [ ] Verify bus.fill icon appears
  - [ ] Tap stop → DeparturesView loads

  ### Regional Bus (route_type 714)
  - [ ] Search regional bus stop
  - [ ] Verify bus.fill icon appears
  - [ ] Tap stop → DeparturesView loads

  ### Ferry (route_type 4)
  - [ ] Search "Circular Quay ferry" or "Manly"
  - [ ] Verify ferry.fill icon appears
  - [ ] Tap stop → DeparturesView loads
  - [ ] Verify departures list shows ferry routes

  ### Light Rail (route_type 900)
  - [ ] Search "Dulwich Hill" or light rail stop
  - [ ] Verify lightrail.fill icon appears
  - [ ] Tap stop → DeparturesView loads
  - [ ] Verify departures list shows light rail routes

  ## Error Handling Tests
  - [ ] Search invalid stop → No crash, shows empty state
  - [ ] Tap stop with missing dict_stop entry → Error message displayed
  - [ ] Backend offline → Graceful error message (not crash)

  ## Logs Validation
  - [ ] Check Xcode console for search_results_ios logs
  - [ ] Verify route_types distribution includes all 7 types across tests
  - [ ] Check departures_request logs show sid and stop_id mapping
  - [ ] No departures_missing_stop_id errors for valid stops
  ```

**Design Constraints:**
- pytest tests must use FastAPI TestClient (not live API calls)
- Populate SAMPLE_STOPS dict from Supabase query (one stop per route type)
- iOS E2E tests are manual (no UI automation yet - Phase 7 scope)
- Log all test results to `.workflow-logs/custom/phase-2-2-*/ios-e2e-test-results.txt`

**Validation:**
```bash
# Backend tests
cd backend && source venv/bin/activate
pytest tests/test_departures_multi_modal.py -v
# Expected: All tests pass (7 route type tests + dict_stop completeness)

# iOS manual tests
# Follow checklist, mark each item complete
# Save results to .workflow-logs/custom/phase-2-2-static-departures-bugfix-modal-coverage/ios-e2e-test-results.txt
```

**References:**
- Pattern: pytest FastAPI testing - `DEVELOPMENT_STANDARDS.md` Section 5 (testing)
- Architecture: `INTEGRATION_CONTRACTS.md` (API envelope format)

---

## Acceptance Criteria

- [ ] Search for 'bus' returns bus stops with bus.fill icon (not just trains)
- [ ] Search for 'ferry' and 'light rail' returns respective stops with correct icons
- [ ] Departures API returns results for sample sids 29443 and 29444 (not empty)
- [ ] All 7 route types (2,4,401,700,712,714,900) are visible and reachable via search
- [ ] DeparturesView displays departures for bus/ferry/light rail stops (not just trains)
- [ ] Backend logs show stop_id type and dict_stop lookup success/failure
- [ ] iOS logs show sid→stop_id mapping for every departures request
- [ ] dict_stop completeness validated: `SELECT COUNT(*) FROM stops = SELECT COUNT(*) FROM dict_stop` in both Supabase and iOS SQLite
- [ ] E2E test passes: search non-train stop → tap → departures load successfully
- [ ] Zero no_static_departures logs for valid stops with scheduled trips

---

## User Blockers (Complete Before Implementation)

None - all prerequisites met. Backend and iOS development environments already configured from Phase 2.1.

---

## Research Notes

**iOS Research Completed:** No iOS research required (all patterns already implemented in Phase 1/2)

**On-Demand Research (During Implementation):** None required

---

## Related Phases

**Phase 1 (Static Data):** Established pattern model and dict_stop mapping; this fixes incomplete mapping

**Phase 2 (Realtime):** Implemented departures API; this fixes bugs where API returns empty for non-train stops

**Phase 2.1 (Fixes):** Fixed route type enum and time filtering; confirmed all 4687 routes in DB; this ensures all are reachable

---

## Exploration Report

Attached: `.workflow-logs/custom/phase-2-2-static-departures-bugfix-modal-coverage/exploration-report.json`

---

**Plan Created:** 2025-11-21
**Estimated Duration:** 4-6 hours (verification + fixes + E2E tests)
