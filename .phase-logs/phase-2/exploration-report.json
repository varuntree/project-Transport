{
  "phase_summary": "Phase 2 adds real-time GTFS-RT integration via Celery workers polling NSW API every 30s, caching per-mode blobs in Redis, merging live delays with static schedules. iOS gets live departures screen with auto-refresh, countdown timers, delay badges. No auth yet—all anonymous endpoints.",
  "key_decisions": [
    {
      "decision": "Adaptive 30s GTFS-RT polling (peak-aware)",
      "rationale": "NSW API updates every 30s. Polling VehiclePositions + TripUpdates per mode (buses, trains, metro, ferries, lightrail) = 10 calls/cycle. 2,880 cycles/day = 28.8K calls (within 60K daily limit). Peak-aware logic stub for future optimization.",
      "reference": "DATA_ARCHITECTURE.md:Section 4.2-4.4, PHASE_2_REALTIME.md:L124-138",
      "critical_constraint": "Must use Redis SETNX lock for singleton task. TTL 75s (VP), 90s (TU) for graceful degradation. Hard timeout 15s, soft 10s to prevent hung workers."
    },
    {
      "decision": "Per-mode blob caching (not per-entity keys)",
      "rationale": "Avoid key explosion (100K+ vehicles → 100K Redis keys). Instead: vp:{mode}:v1, tu:{mode}:v1 = 10 total keys. Gzip compress JSON blobs (~70% reduction). Client-side filtering by route/trip.",
      "reference": "DATA_ARCHITECTURE.md:Section 4.5, PHASE_2_REALTIME.md:L283-287",
      "critical_constraint": "Gzip before cache (gzip.compress), decompress on read. TTL > poll interval to avoid cache misses between cycles."
    },
    {
      "decision": "3-queue Celery architecture (critical/normal/batch)",
      "rationale": "Isolate time-sensitive RT poller (critical, 1 worker, singleton) from parallel tasks (normal: alerts, APNs) and long-running (batch: GTFS sync). Prevents head-of-line blocking.",
      "reference": "BACKEND_SPECIFICATION.md:Section 4.2, PHASE_2_REALTIME.md:L100-138",
      "critical_constraint": "Worker A: -Q critical -c 1 (singleton). Worker B: -Q normal,batch -c 2 --autoscale=3,1. Beat scheduler required for periodic tasks."
    },
    {
      "decision": "Merge static schedules + RT delays in API layer",
      "rationale": "iOS offline-first: GRDB has static schedules, API enriches with live delays from Redis. Pattern model query joins trips→pattern_stops→routes, then lookup trip_id in Redis tu:{mode}:v1 blob for delay_s.",
      "reference": "PHASE_2_REALTIME.md:L375-451, INTEGRATION_CONTRACTS.md:L163-228",
      "critical_constraint": "Route ID heuristics determine mode (T*/BMT→trains, M→metro, F→ferries, L→lightrail, else→buses). Fallback to delay_s=0 if Redis miss."
    },
    {
      "decision": "iOS Timer-based auto-refresh (30s)",
      "rationale": "SwiftUI Timer triggers API refetch every 30s while DeparturesView visible. Pull-to-refresh manual trigger. minutesUntil computed property recalculates on each render (no timer needed for countdown).",
      "reference": "IOS_APP_SPECIFICATION.md:Section 5.2, PHASE_2_REALTIME.md:L633-646",
      "critical_constraint": "Timer.invalidate() in onDisappear to prevent memory leaks. Timer scheduled on main thread (@MainActor)."
    },
    {
      "decision": "Graceful degradation (stale cache fallback)",
      "rationale": "If Redis TTL expires or NSW API fails, serve static schedules (realtime: false, delay_s: 0). No 503 errors—app remains functional offline/degraded. Log stale state, don't crash.",
      "reference": "BACKEND_SPECIFICATION.md:Section 5.3, PHASE_2_REALTIME.md:L800-811",
      "critical_constraint": "Handle gzip.decompress errors, Redis misses, NSW 429 rate limits. All exceptions caught, logged, return empty/static data."
    }
  ],
  "previous_phase_state": {
    "completed": [
      "Backend: GTFS static data loaded to Supabase (pattern model, PostGIS, <350MB)",
      "Backend: GET /stops/nearby, /stops/{id}, /stops/{id}/departures (static schedules only)",
      "Backend: GET /routes, /gtfs/version, /gtfs/download",
      "Backend: iOS SQLite generated (15-20MB, dict encoding, FTS5)",
      "iOS: GRDB bundled, DatabaseManager singleton",
      "iOS: Stop/Route models with FTS5 search",
      "iOS: SearchView (FTS5 stop name search <200ms)",
      "iOS: StopDetailsView, RouteListView",
      "iOS: Offline browsing functional (no network required)"
    ],
    "files_created": [
      "backend/app/services/gtfs_service.py",
      "backend/app/services/ios_db_generator.py",
      "backend/app/tasks/gtfs_static_sync.py",
      "backend/app/api/v1/stops.py",
      "backend/app/api/v1/routes.py",
      "backend/app/api/v1/gtfs.py",
      "backend/schemas/migrations/001_initial_schema.sql",
      "backend/ios_output/gtfs.db",
      "SydneyTransit/Core/Database/DatabaseManager.swift",
      "SydneyTransit/Data/Models/Stop.swift",
      "SydneyTransit/Data/Models/Route.swift",
      "SydneyTransit/Features/Search/SearchView.swift",
      "SydneyTransit/Features/Stops/StopDetailsView.swift",
      "SydneyTransit/Features/Routes/RouteListView.swift"
    ],
    "current_state": "Backend :8000 serving static GTFS data. iOS builds, offline browsing works. No Celery, no Redis caching, no real-time departures yet. Phase 1 complete (10 checkpoints, all acceptance criteria passed).",
    "blockers": []
  },
  "checkpoints": [
    {
      "name": "Celery App Config + 3 Queues",
      "goal": "Configure Celery with 3 queues (critical/normal/batch), Beat scheduler, timezone-aware",
      "backend_work": [
        "Add celery[redis]==5.3.4, redis==5.0.1, gtfs-realtime-bindings==1.0.0 to requirements.txt",
        "Create app/tasks/celery_app.py (broker=REDIS_URL, include=['app.tasks.gtfs_rt_poller'])",
        "Define 3 queues: critical (RT poller), normal (alerts, APNs), batch (GTFS sync)",
        "Beat schedule: poll_gtfs_rt (30s), sync_gtfs_static (03:10 Sydney cron)",
        "Config: task_serializer=json, timezone='Australia/Sydney', worker_prefetch_multiplier=1"
      ],
      "ios_work": [],
      "validation": "celery -A app.tasks.celery_app inspect registered # Should list 0 tasks (none implemented yet), no import errors"
    },
    {
      "name": "GTFS-RT Poller Task (VehiclePositions + TripUpdates)",
      "goal": "Poll 5 modes × 2 feeds every 30s, parse protobuf, cache gzipped JSON blobs",
      "backend_work": [
        "Create app/tasks/gtfs_rt_poller.py",
        "@celery_app.task(queue='critical', time_limit=15, soft_time_limit=10, max_retries=0)",
        "Redis SETNX lock: lock:poll_gtfs_rt (TTL 30s, skip if already running)",
        "Loop MODES = ['buses', 'sydneytrains', 'metro', 'ferries', 'lightrail']",
        "fetch_gtfs_rt(mode, 'vehiclepos'): requests.get(NSW API, headers={'Authorization': 'apikey KEY'}, timeout=8)",
        "parse_vehicle_positions(pb_data): gtfs_realtime_pb2.FeedMessage().ParseFromString()",
        "Extract {vehicle_id, trip_id, route_id, lat, lon, bearing, speed, timestamp}",
        "Repeat for 'realtime' feed → parse_trip_updates (extract {trip_id, route_id, delay_s, stop_time_updates})",
        "cache_blob(redis, f'vp:{mode}:v1', parsed_vp, ttl=75): gzip.compress(json.dumps(data))",
        "cache_blob(redis, f'tu:{mode}:v1', parsed_tu, ttl=90)",
        "Log: logger.info('poll_gtfs_rt_complete', modes=MODES, duration_ms=elapsed)"
      ],
      "ios_work": [],
      "validation": "Start worker+beat, wait 30s, redis-cli KEYS vp:* # Expect 5 keys, KEYS tu:* # Expect 5 keys, GET vp:buses:v1 # Binary gzipped blob"
    },
    {
      "name": "Worker Startup Scripts",
      "goal": "Create bash scripts to start Worker A (critical), Worker B (normal+batch), Beat",
      "backend_work": [
        "Create scripts/start_worker_critical.sh: celery -A app.tasks.celery_app worker -Q critical -c 1 --loglevel=info",
        "Create scripts/start_worker_service.sh: celery -A app.tasks.celery_app worker -Q normal,batch -c 2 --autoscale=3,1 --loglevel=info",
        "Create scripts/start_beat.sh: celery -A app.tasks.celery_app beat --loglevel=info",
        "chmod +x scripts/*.sh"
      ],
      "ios_work": [],
      "validation": "bash scripts/start_worker_critical.sh # Starts without errors, logs show worker_critical@hostname ready"
    },
    {
      "name": "Real-Time Departures Service (Merge Static + RT)",
      "goal": "Fetch static schedules from Supabase, enrich with Redis RT delays",
      "backend_work": [
        "Create app/services/realtime_service.py",
        "async def get_realtime_departures(stop_id, now_secs, limit=10)",
        "Step 1: Query Supabase pattern model (same as Phase 1 /stops/{id}/departures)",
        "Step 2: Determine modes from route_ids (heuristic: T*/BMT→trains, M→metro, F→ferries, L→lightrail, else→buses)",
        "Step 3: Fetch tu:{mode}:v1 from Redis, decompress gzip, parse JSON, build trip_delays = {trip_id: delay_s}",
        "Step 4: Merge static_deps + trip_delays → realtime_dep_secs = dep_secs + delay_s",
        "Return [{trip_id, route_short_name, headsign, scheduled_time_secs, realtime_time_secs, delay_s, realtime: bool}]",
        "Sort by realtime_time_secs, limit to 10"
      ],
      "ios_work": [],
      "validation": "Import in Python REPL, call get_realtime_departures('200060', 32400, 10) # Returns list with delay_s != 0 if NSW has delays"
    },
    {
      "name": "Update Stops API for Real-Time",
      "goal": "Replace static departures endpoint with realtime_service",
      "backend_work": [
        "Update app/api/v1/stops.py",
        "Replace @router.get('/stops/{stop_id}/departures') handler",
        "from app.services.realtime_service import get_realtime_departures",
        "Default time to now (pytz.timezone('Australia/Sydney')), convert to seconds since midnight",
        "Call get_realtime_departures(stop_id, now_secs, limit)",
        "Return SuccessResponse(data=departures)"
      ],
      "ios_work": [],
      "validation": "curl 'http://localhost:8000/api/v1/stops/200060/departures' # Returns realtime: true for delayed trips, delay_s != 0"
    },
    {
      "name": "iOS Departure Model + Repository",
      "goal": "Create Departure model with countdown logic, repository protocol",
      "backend_work": [],
      "ios_work": [
        "Create Data/Models/Departure.swift",
        "struct Departure: Codable, Identifiable { trip_id, route_short_name, headsign, scheduled_time_secs, realtime_time_secs, delay_s, realtime, departure_time }",
        "var minutesUntil: Int (computed: realtime_time_secs - now_secs / 60)",
        "var delayText: String? ('+X min' if delay_s > 0, else nil)",
        "Create Data/Repositories/DeparturesRepository.swift (protocol + impl)",
        "func fetchDepartures(stopId: String) async throws -> [Departure]",
        "APIClient.request(APIEndpoint.getDepartures(stopId: stopId))"
      ],
      "validation": "Xcode builds, no errors on Departure model, DeparturesRepositoryImpl compiles"
    },
    {
      "name": "iOS Departures ViewModel (Auto-Refresh)",
      "goal": "ViewModel with Timer-based 30s refresh, loading/error states",
      "backend_work": [],
      "ios_work": [
        "Create Features/Departures/DeparturesViewModel.swift",
        "@MainActor class DeparturesViewModel: ObservableObject",
        "@Published var departures: [Departure] = [], isLoading = false, errorMessage: String?",
        "func loadDepartures(stopId: String) async { isLoading=true, fetch from repo, handle errors }",
        "func startAutoRefresh(stopId: String): Timer.scheduledTimer(withTimeInterval: 30, repeats: true)",
        "func stopAutoRefresh(): refreshTimer?.invalidate()"
      ],
      "validation": "Xcode builds, ViewModel compiles, Timer import Foundation, no Combine needed"
    },
    {
      "name": "iOS Departures View (Countdown UI)",
      "goal": "SwiftUI view with List, DepartureRow, auto-refresh on appear",
      "backend_work": [],
      "ios_work": [
        "Create Features/Departures/DeparturesView.swift",
        "List { ForEach(viewModel.departures) { DepartureRow(departure: $0) } }",
        ".refreshable { await viewModel.loadDepartures(stopId: stop.sid) }",
        ".onAppear { Task { await viewModel.loadDepartures(stopId: stop.sid) }; viewModel.startAutoRefresh(stopId: stop.sid) }",
        ".onDisappear { viewModel.stopAutoRefresh() }",
        "Create DepartureRow: HStack { route badge, headsign + delayText, Spacer, minutesUntil + departure_time }"
      ],
      "validation": "Tap stop → 'View Departures' → list shows, countdown updates on refresh, delay badges orange if delay_s > 0"
    },
    {
      "name": "Integration Test: Backend + iOS Real-Time",
      "goal": "End-to-end test: Worker polls → Redis caches → API serves → iOS displays",
      "backend_work": [],
      "ios_work": [],
      "validation": "Start backend+workers+beat, iOS launch, navigate to departures, verify: list populates, delays show (+X min), auto-refresh every 30s, pull-to-refresh works"
    },
    {
      "name": "Graceful Degradation Test",
      "goal": "Verify offline/stale cache behavior",
      "backend_work": [],
      "ios_work": [],
      "validation": "Stop Celery workers, wait 2min (TTL expires), curl departures # Returns static schedules (realtime: false, delay_s: 0), iOS shows departures without network (static)"
    }
  ],
  "critical_patterns": [
    {
      "pattern": "Celery task decorator (time limits, retries, queue routing)",
      "example_location": "PHASE_2_REALTIME.md:L161-168",
      "reference": "BACKEND_SPECIFICATION.md:Section 4.4"
    },
    {
      "pattern": "Redis SETNX singleton lock (idempotency)",
      "example_location": "PHASE_2_REALTIME.md:L173-178",
      "reference": "DATA_ARCHITECTURE.md:Section 4.7"
    },
    {
      "pattern": "Gzip blob caching (compress before store)",
      "example_location": "PHASE_2_REALTIME.md:L283-287",
      "reference": "DATA_ARCHITECTURE.md:Section 4.5"
    },
    {
      "pattern": "iOS Timer auto-refresh (@MainActor, invalidate on disappear)",
      "example_location": "PHASE_2_REALTIME.md:L633-645",
      "reference": "IOS_APP_SPECIFICATION.md:Section 5.2"
    },
    {
      "pattern": "SwiftUI .refreshable modifier (async pull-to-refresh)",
      "example_location": "PHASE_2_REALTIME.md:L681-684",
      "reference": "IOS_APP_SPECIFICATION.md:Section 5.1"
    }
  ],
  "ios_research_needed": [
    "Timer.scheduledTimer main thread scheduling (confirm @MainActor sufficient)",
    "SwiftUI List item refresh without full reload (optimize countdown updates)",
    "NetworkMonitor for offline detection (NWPathMonitor, show offline banner)",
    "APIClient timeout handling (URLSession timeout vs Celery soft_time_limit alignment)"
  ],
  "external_services_research": [
    "NSW API GTFS-RT feed reliability (uptime stats, 429 rate limit window)",
    "Redis Railway auto-scaling triggers (memory >70%, connection pool limits)",
    "Celery Beat DST handling (Australia/Sydney timezone transitions, cron schedule drift)",
    "GTFS-RT protobuf schema stability (gtfs-realtime-bindings version pinning)"
  ],
  "user_blockers": [
    "Must verify NSW API key has GTFS-RT access (test vehiclepos/realtime/alerts endpoints)",
    "Must verify Redis Railway connection (redis-cli PING test)",
    "Must have 3 terminal windows for backend+worker+beat (or use tmux/screen)",
    "Must wait 30s after worker start for first Redis cache (no instant data)"
  ],
  "acceptance_criteria": [
    "Backend: Celery worker starts without import errors",
    "Backend: Beat schedules poll_gtfs_rt every 30s",
    "Backend: Redis has 10 keys after 30s (vp:* and tu:* for 5 modes)",
    "Backend: Redis keys have TTL 60-90s (TTL vp:buses:v1 returns 60-75)",
    "Backend: GET /stops/200060/departures returns realtime: true for ≥1 trip (if NSW has delays)",
    "Backend: Stale cache test: Stop workers, wait 2min, API returns realtime: false (graceful degradation)",
    "iOS: DeparturesView shows list of departures",
    "iOS: Countdown '5 min' updates after 30s auto-refresh (becomes '4 min')",
    "iOS: Delay badges show orange '+2 min' when delay_s > 0",
    "iOS: Pull-to-refresh triggers network call, loading indicator appears",
    "iOS: Timer invalidates on back navigation (no memory leak)",
    "iOS: Offline mode test: Wi-Fi off, departures fail gracefully (error message, no crash)",
    "Logs: Structured JSON events (poll_gtfs_rt_started, vp_cached, tu_cached) in worker output",
    "Logs: No PII (no user IDs yet—Phase 3), no full protobuf dumps (log counts only)"
  ]
}
