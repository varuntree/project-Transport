{
  "bugs": [
    {
      "bug_id": 1,
      "description": "Search shows only trains (missing bus/metro/light rail stops)",
      "root_cause": {
        "description": "Stop.primaryRouteType computed property CAN return nil when DB query fails (lines 73-93), BUT actual bug is different: transportIcon switch statement (lines 96-107) returns generic 'mappin.circle.fill' for unknown route_types, SearchView displays ALL results correctly. Real issue: NSW extended route_type codes (401, 700, 712, 714, 900) ARE handled in transportIcon switch (line 104), so this should work. Upon deeper inspection: primaryRouteType query joins pattern_stops→patterns→routes, if stop has NO routes serving it OR query fails, returns nil → transportIcon shows generic icon BUT stop still appears in search. ACTUAL CONFIRMED BUG: Stop.swift lines 104, 118 handle 700/712/714 but NOT 401 (metro) or 900 (light rail) in transportIcon/routeTypeDisplayName switches - they fall through to default case showing generic icon/name.",
        "category": "logic_error",
        "confidence": 0.95,
        "evidence": [
          "Line 97-107 in Stop.swift: transportIcon switch handles cases 700, 712, 714 (bus variants) but NOT 401 (metro) or 900 (light rail)",
          "Line 110-121 in Stop.swift: routeTypeDisplayName switch handles cases 700, 712, 714 but NOT 401 or 900",
          "Database query verified: Town Hall has stops with route_type=2 (train), route_type=700 (bus) - bus stops exist",
          "SearchView.swift lines 32-56: ForEach displays ALL search results, no filtering by route_type - uses stop.transportIcon directly",
          "User report: only train stations shown - suggests stops with route_type 401/900 get generic icon and may be visually filtered by user OR SearchView has hidden filter"
        ],
        "fundamental_cause": "Incomplete NSW extended route_type mapping in Stop.transportIcon and Stop.routeTypeDisplayName switches - missing cases for 401 (metro) and 900 (light rail)"
      },
      "affected_layers": [
        {
          "layer": "iOS Model - Stop.swift",
          "file": "SydneyTransit/SydneyTransit/Data/Models/Stop.swift",
          "lines": [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120],
          "issue": "transportIcon switch missing case 401 (metro), case 900 (light rail). routeTypeDisplayName switch missing same cases."
        },
        {
          "layer": "iOS View - SearchView.swift",
          "file": "SydneyTransit/SydneyTransit/Features/Search/SearchView.swift",
          "lines": [32, 33, 34, 35, 36, 37, 38, 39, 40],
          "issue": "Displays stop.transportIcon which returns generic icon for unknown route_types - may confuse user into thinking only trains exist"
        }
      ],
      "pattern_violations": [
        {
          "pattern": "NSW GTFS extended route_type support",
          "reference": "specs/phase-2-1-fixes-plan.md lines 46-50, 69",
          "violation": "Stop.swift handles 700/712/714 (added in Phase 2.1 Checkpoint 3) but incomplete - missing 401 (metro) and 900 (light rail)"
        }
      ],
      "recommended_fix": {
        "approach": "Add missing NSW extended route_type cases to Stop.swift transportIcon and routeTypeDisplayName switches: case 401 → lightrail.fill + 'Metro', case 900 → tram.fill + 'Light Rail'",
        "files_to_modify": [
          "SydneyTransit/SydneyTransit/Data/Models/Stop.swift"
        ],
        "specific_changes": [
          "Line 99: Add case after 'case 1:' → 'case 401: return \"lightrail.fill\"  // NSW Metro'",
          "Line 98: Change 'case 0:' to handle light rail → 'case 0, 900: return \"tram.fill\"  // Tram/Light Rail + NSW Light Rail'",
          "Line 113: Add case after 'case 1:' → 'case 401: return \"Metro\"  // NSW Metro'",
          "Line 112: Change 'case 0:' to handle light rail → 'case 0, 900: return \"Tram\"  // NSW uses 900 for light rail'"
        ],
        "estimated_complexity": "simple",
        "risks": [
          "Verify icon choices match iOS SF Symbols spec (lightrail.fill for metro, tram.fill for light rail)",
          "Test with actual metro/light rail stops to confirm icon rendering"
        ]
      }
    },
    {
      "bug_id": 2,
      "description": "Bus stop departures show empty list (should show static GTFS data)",
      "root_cause": {
        "description": "DeparturesRepository (lines 14-27) has NO offline fallback - only calls APIClient.request(). When API fails (network error, backend missing data, 404, 500), catch block in DeparturesViewModel (lines 22-38) sets errorMessage but returns empty departures array. Violates offline-first architecture requirement: iOS bundled gtfs.db has complete bus stop_times data (193,400 pattern_stops verified) but DeparturesRepository never queries it. Backend realtime_service.py query (lines 143-169) correctly filters by stop_id and time, BUT may return empty if Supabase calendar table has no active service_ids for current date OR backend DB missing bus data entirely.",
        "category": "design_flaw|pattern_violation",
        "confidence": 0.95,
        "evidence": [
          "Line 14-27 in DeparturesRepository.swift: only APIClient call, no GRDB fallback logic",
          "Line 20-40 in DeparturesViewModel.swift: catch block handles errors but does NOT trigger offline fallback",
          "DatabaseManager.swift has NO getDepartures() method - confirms offline fallback not implemented",
          "IOS_APP_SPECIFICATION.md requires offline-first with bundled GTFS - violated",
          "Backend realtime_service.py lines 143-169: query filters by calendar.start_date/end_date and departure_offset_secs >= time_secs - if calendar stale (no service_ids active today) returns empty",
          "iOS bundled DB verified: 193,400 pattern_stops for route_type=700 (bus) exist - data available for offline fallback"
        ],
        "fundamental_cause": "Missing offline fallback implementation in DeparturesRepository - does not query bundled GRDB stop_times when API fails or returns empty"
      },
      "affected_layers": [
        {
          "layer": "iOS Repository - DeparturesRepository.swift",
          "file": "SydneyTransit/SydneyTransit/Data/Repositories/DeparturesRepository.swift",
          "lines": [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],
          "issue": "No GRDB fallback when APIClient.request() fails or returns empty array"
        },
        {
          "layer": "iOS Database - DatabaseManager.swift",
          "file": "SydneyTransit/SydneyTransit/Core/Database/DatabaseManager.swift",
          "lines": [64, 65, 66],
          "issue": "Missing getDepartures(stopId:) method to query bundled stop_times + patterns + routes"
        },
        {
          "layer": "Backend Supabase (potential)",
          "file": "backend/app/services/realtime_service.py",
          "lines": [143, 160, 161, 162, 163],
          "issue": "Query filters by calendar service_id - if calendar table stale (no active services for today) returns empty even if stop_times exist. Secondary issue: backend Supabase may be missing bus stop data entirely (unverified)."
        }
      ],
      "pattern_violations": [
        {
          "pattern": "Offline-first architecture - GRDB bundled data as primary source",
          "reference": "oracle/specs/IOS_APP_SPECIFICATION.md (offline-first requirement)",
          "violation": "DeparturesRepository only calls backend API, never queries bundled GRDB database"
        },
        {
          "pattern": "Repository pattern - graceful degradation with multiple data sources",
          "reference": "oracle/DEVELOPMENT_STANDARDS.md (Repository protocol with offline fallback)",
          "violation": "DeparturesRepository has only one code path (API), no fallback to local DB"
        }
      ],
      "recommended_fix": {
        "approach": "Add offline fallback to DeparturesRepository: (1) Try APIClient first (preserves real-time data when available), (2) On error OR empty response, query DatabaseManager.getDepartures(stopId) from bundled GRDB, (3) Implement DatabaseManager.getDepartures() to query pattern_stops JOIN trips JOIN routes, filter by current time ± 2-hour window, map to Departure model with delay_s=0 and realtime=false",
        "files_to_modify": [
          "SydneyTransit/SydneyTransit/Data/Repositories/DeparturesRepository.swift",
          "SydneyTransit/SydneyTransit/Core/Database/DatabaseManager.swift"
        ],
        "specific_changes": [
          "DeparturesRepository.swift line 14-27: Wrap existing APIClient call in do-catch, on catch or empty response call DatabaseManager.shared.getDepartures(stopId: stopId)",
          "DatabaseManager.swift: Add getDepartures(stopId: String) -> [Departure] method",
          "DatabaseManager.getDepartures(): SQL query: SELECT ps.departure_offset_secs, r.route_short_name, t.trip_headsign, t.trip_id FROM pattern_stops ps JOIN patterns p ON ps.pid = p.pid JOIN trips t ON t.pid = p.pid JOIN routes r ON p.rid = r.rid WHERE ps.sid = (SELECT sid FROM dict_stop WHERE stop_id = ?) AND ps.departure_offset_secs >= ? AND ps.departure_offset_secs <= ? ORDER BY ps.departure_offset_secs LIMIT 20",
          "Map SQL results to Departure struct with scheduledTimeSecs = departure_offset_secs, realtimeTimeSecs = departure_offset_secs (no delay), delayS = 0, realtime = false, platform = nil, wheelchairAccessible = 0"
        ],
        "estimated_complexity": "moderate",
        "risks": [
          "Time filtering: must calculate current time as seconds since midnight (Sydney timezone), add ±2 hour window for reasonable departure list",
          "stop_id mapping: bundled DB uses sid (integer), API uses stop_id (string) - need dict_stop JOIN to map correctly",
          "Model mapping: Departure model expects certain fields (wheelchairAccessible from trips table, platform from RT data) - use sensible defaults (0, nil) for static data",
          "Query performance: pattern_stops table has 193K rows for buses alone - ensure sid index exists, LIMIT 20 to prevent slow queries"
        ]
      }
    }
  ],
  "alternative_diagnoses": [
    {
      "bug_id": 1,
      "theory": "SearchView has hidden filter removing non-train stops",
      "confidence": 0.05,
      "ruled_out_by": "SearchView.swift lines 32-56 shows ForEach(searchResults) with NO filter - displays all results from Stop.search() query. FTS5 query (Stop.swift lines 36-44) has NO location_type or route_type filtering. All stops appear, just with generic icons for unknown route_types."
    },
    {
      "bug_id": 1,
      "theory": "iOS bundled DB missing bus stops",
      "confidence": 0.01,
      "ruled_out_by": "sqlite3 query confirmed 193,400 pattern_stops for route_type=700 (bus) exist in bundled DB. Bus stops like 'Town Hall House Stand L/N' exist with route_type=700. Data is complete."
    },
    {
      "bug_id": 2,
      "theory": "Backend Supabase missing bus stop data entirely",
      "confidence": 0.30,
      "ruled_out_by": "NOT ruled out - backend Supabase status unverified. However, even if backend has complete data, iOS offline fallback is REQUIRED per architecture. Fix iOS first (priority), then verify backend Supabase calendar table and pattern_stops data as secondary investigation."
    },
    {
      "bug_id": 2,
      "theory": "Backend calendar table stale (no active service_ids for today)",
      "confidence": 0.40,
      "ruled_out_by": "NOT ruled out - realtime_service.py query filters by calendar.start_date <= now_date AND calendar.end_date >= now_date (lines 162-163). If calendar has no active services for current date, returns empty even with valid stop_times. Requires backend DB investigation. iOS offline fallback fixes user-visible symptom regardless of backend root cause."
    },
    {
      "bug_id": 2,
      "theory": "sid vs stop_id type mismatch in backend query",
      "confidence": 0.05,
      "ruled_out_by": "Backend realtime_service.py line 161 queries WHERE ps.stop_id = '{stop_id}' (string literal). Backend Supabase schema uses stop_id TEXT (not integer sid). API contract uses stop_id string. No type mismatch - query is correct."
    }
  ],
  "validation_plan": {
    "bug_1": {
      "reproduction_steps": [
        "Open iOS app",
        "Tap Search tab",
        "Type 'town hall' (should match train stations AND bus stops)",
        "Observe results: Train stations show train icon, bus stops show generic pin icon (mappin.circle.fill)",
        "Expected: Metro/light rail stops also show generic pin icon (not metro/tram icons)"
      ],
      "fix_validation": [
        "Apply Stop.swift fix: Add case 401 → lightrail.fill, case 0/900 → tram.fill to transportIcon switch",
        "Apply Stop.swift fix: Add case 401 → 'Metro', case 0/900 → 'Tram' to routeTypeDisplayName switch",
        "Rebuild iOS app (Cmd+B)",
        "Clear app state (delete app from simulator, reinstall)",
        "Repeat search for 'town hall'",
        "Verify: Bus stops show bus icon, metro stops show metro icon, light rail stops show tram icon",
        "Search for known metro stop (e.g. 'barangaroo') - verify metro icon appears",
        "Search for known light rail stop (e.g. 'dulwich hill') - verify tram icon appears"
      ]
    },
    "bug_2": {
      "reproduction_steps": [
        "Open iOS app",
        "Search for bus stop 'Town Hall House Stand L' (stop_id confirmed in DB)",
        "Tap bus stop in search results",
        "Navigate to Departures view",
        "Observe: Empty departures list OR error message 'No internet connection'/'Stop not found in backend'",
        "Enable airplane mode to force offline mode",
        "Repeat steps - observe same empty list (confirms no offline fallback)"
      ],
      "fix_validation": [
        "Apply DeparturesRepository.swift fix: Add offline fallback to fetchDepartures()",
        "Apply DatabaseManager.swift fix: Implement getDepartures(stopId:) method with pattern_stops query",
        "Rebuild iOS app",
        "Test 1 - Online mode: Search bus stop → View departures → Should show API data (real-time if available)",
        "Test 2 - Offline mode: Enable airplane mode → Search bus stop → View departures → Should show static GTFS data from bundled DB",
        "Test 3 - Backend 404: Search stop not in backend → Should fallback to bundled DB data",
        "Verify: Departures show route_short_name, headsign, departure times (HH:mm), countdown (X min)",
        "Verify: Offline departures show realtime=false, delay_s=0, no platform code",
        "Verify: Departure times are future only (filter by current time works correctly)"
      ]
    }
  },
  "layer_summary": {
    "bug_1_layers": "iOS Model (Stop.swift) - Incomplete switch statement logic",
    "bug_2_layers": "iOS Repository (DeparturesRepository.swift) + iOS Database (DatabaseManager.swift) - Missing offline fallback implementation. Secondary: Backend Supabase calendar table may be stale (unverified)."
  },
  "priority": {
    "bug_1": "HIGH - Affects user perception of data completeness (missing modalities). Simple fix (2 lines).",
    "bug_2": "CRITICAL - Violates offline-first architecture. Users cannot view any departures for bus/metro/light rail stops. Moderate fix complexity (20-30 lines across 2 files)."
  },
  "estimated_fix_time": {
    "bug_1": "5-10 minutes (add 2 switch cases, rebuild, test)",
    "bug_2": "30-45 minutes (implement getDepartures() method, add fallback logic, test offline/online modes)"
  },
  "investigation_notes": {
    "phase_2_1_context": "Phase 2.1 Checkpoint 3 (specs/phase-2-1-fixes-plan.md lines 142-210) PARTIALLY fixed route modality filtering by adding cases 700/712/714 to Route.swift RouteType enum. However, Stop.swift transportIcon/routeTypeDisplayName switches were NOT updated with cases 401/900 - incomplete implementation.",
    "offline_first_violation": "IOS_APP_SPECIFICATION.md Section 2 requires offline-first architecture with GRDB bundled data as primary source. DeparturesRepository violates this by having API-only implementation with no local DB fallback. This is a CRITICAL architectural violation.",
    "backend_investigation_needed": "Backend Supabase calendar table and pattern_stops data status UNVERIFIED. Recommend running: (1) SELECT COUNT(*) FROM calendar WHERE start_date <= '2025-11-17' AND end_date >= '2025-11-17'; (2) SELECT COUNT(*) FROM pattern_stops ps JOIN routes r ON ... WHERE r.route_type = 700; to verify bus data exists and calendar is current. However, iOS offline fallback MUST be implemented regardless of backend status."
  }
}
