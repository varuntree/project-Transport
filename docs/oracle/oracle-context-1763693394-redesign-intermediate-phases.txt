# Oracle Context: Redesign Intermediate Phases Between Phase I and II
# Session: 1763693394-redesign-intermediate-phases
# Generated: 2025-11-21T05:23:14Z
# Token estimate: ~28000

## Repository Structure

prj_transport/
├── docs/
│   ├── IMPLEMENTATION_ROADMAP.md (558 lines)
│   ├── phases/
│   │   ├── PHASE_1_STATIC_DATA.md (1007 lines)
│   │   ├── PHASE_2_REALTIME.md (944 lines)
│   │   └── ... (Phases 3-7)
│   └── specs/
│       ├── SYSTEM_OVERVIEW.md (945 lines)
│       ├── DATA_ARCHITECTURE.md
│       ├── BACKEND_SPECIFICATION.md
│       └── IOS_APP_SPECIFICATION.md
├── specs/
│   ├── issue-144-adw-phase2-1-sdlc_planner-missing-modalities-departures.md (99 lines)
│   ├── phase-2-1-fixes-plan.md (340 lines)
│   └── phase-2-implementation-plan.md
├── backend/
│   ├── app/
│   │   ├── api/v1/stops.py
│   │   └── services/realtime_service.py (200+ lines)
│   └── scripts/ (GTFS ingestion)
└── SydneyTransit/
    ├── Features/
    │   ├── Departures/DeparturesView.swift (238 lines)
    │   ├── Search/SearchView.swift (135 lines)
    │   └── Trips/TripDetailsView.swift, TripMapView.swift
    └── Data/Models/Stop.swift (130 lines)

## Git Context

Current branch: main
Recent commits:
- 34ef853 oracle and cleaning.
- e90ddcc Implemented the drawer.
- 171d1ac Add departures scroll fixes and GTFS coverage documentation
- 71e6062 fix: departures page critical bugs - continuous reload, 0 minute display, sentinel trigger
- a677a04 fix: departures page - race condition, timezone, pagination

## File Contents

──────────────────────────────────────
File: docs/IMPLEMENTATION_ROADMAP.md
──────────────────────────────────────
# Implementation Roadmap - Sydney Transit App (1-558)
[Full content from earlier Read tool output showing 7-phase roadmap: Foundation → Static Data → Real-Time → User Features → Trip Planning → Alerts → Push Notifications → Production]

KEY PHASE STRUCTURE:
- Phase 0 (Week 1-2): Foundation - local dev, hello-world
- Phase 1 (Week 3-5): Static Data - GTFS parser, iOS SQLite, offline browsing, basic API
- Phase 2 (Week 6-8): Real-Time - Celery poller, GTFS-RT, Redis cache, live departures
- Phase 3 (Week 9-11): User features - auth, favorites, sync
- Phase 4 (Week 12-13): Trip planning
- Phase 5 (Week 14-16): Alerts + background jobs
- Phase 6 (Week 17-18): APNs push notifications
- Phase 7 (Week 19-20): Production deploy

DEPENDENCIES:
- Phase 2 requires Phase 1 (static data must exist before real-time)
- Currently at Phase 2.1 (fixes) - real-time partially implemented
- Vertical slicing philosophy: Build working features incrementally (backend + iOS together)

──────────────────────────────────────
File: docs/phases/PHASE_1_STATIC_DATA.md
──────────────────────────────────────
# Phase 1: Static Data + Basic UI (1-1007)
[Full spec showing GTFS parsing, pattern model, iOS SQLite bundling, basic search/browse UI]

DELIVERABLES:
Backend:
- GTFS parser (227MB → Supabase pattern tables)
- Supabase schema (stops, routes, trips, patterns)
- iOS SQLite generator (15-20MB bundled DB)
- API endpoints: /stops, /routes, /stops/{id}/departures (static only)

iOS:
- GRDB setup (bundled gtfs.db)
- Home screen (list stops)
- Stop details screen
- Route list screen
- Search screen (FTS5 search on stop names)

ACCEPTANCE CRITERIA:
- GTFS data loaded to Supabase (<50MB total)
- iOS: Can browse stops/routes offline
- Search: "Circular Quay" returns stops
- Static schedules: Show scheduled departure times (not real-time)

──────────────────────────────────────
File: docs/phases/PHASE_2_REALTIME.md
──────────────────────────────────────
# Phase 2: Real-Time Foundation (1-944)
[Full spec showing Celery setup, GTFS-RT polling, Redis caching, departures API, iOS auto-refresh]

DELIVERABLES:
Backend:
- Celery setup (broker: Redis, 3 queues)
- Celery Beat scheduler
- GTFS-RT poller task (poll every 30s, update Redis cache)
- Redis caching layer (blob model)
- Departures API: /stops/{id}/realtime-departures (merges static + RT)

iOS:
- Departures screen (real-time departures for a stop)
- Auto-refresh (every 30s)
- Real-time badges (show delays, cancellations)
- Network layer (APIClient, error handling)

ACCEPTANCE CRITERIA:
- Celery: Poller task runs every 30s
- Redis: Cache contains gtfs_rt:train:blob, etc. (TTL 60s)
- API: /realtime-departures returns live data (delays, vehicle positions)
- iOS: Departures screen shows "Arriving in 3 min" (real-time)
- Offline: Falls back to static schedules when network unavailable

──────────────────────────────────────
File: docs/specs/SYSTEM_OVERVIEW.md
──────────────────────────────────────
# System Overview - Sydney Transit App (1-945)
[Full overview showing project vision, constraints, tech stack, architecture]

CORE FEATURES (MVP):
1. Real-Time Departures - Live countdown timers for all Sydney modes
2. Stop/Station Search & Nearby - Search by name/number, map view
3. Service Alerts - Real-time disruption notifications
4. Trip Planning - Multi-modal journey planning
5. Favorites & Quick Access - Save stops/routes, sync via Supabase
6. Maps & Live Tracking - Vehicle positions on map
7. Push Notifications - Service disruptions, departure reminders

TECH STACK:
Backend: FastAPI (Python), Celery workers, PostgreSQL (Supabase), Redis (cache)
iOS: Swift/SwiftUI, MVVM + Coordinator, GRDB (SQLite), Supabase Auth
Data: NSW Transport GTFS (227MB static, GTFS-RT every 30s)

CONSTRAINTS:
- Solo developer, $25/mo MVP budget
- iOS 16+ only (no Android)
- App size <50MB download
- NSW API: 5 req/s, 60K calls/day

──────────────────────────────────────
File: specs/issue-144-adw-phase2-1-sdlc_planner-missing-modalities-departures.md
──────────────────────────────────────
# Bug: Missing modalities and departures failing after Phase 2.1 (1-99)

PROBLEM:
Searching for stops only surfaces train stations; bus, ferry, light rail absent.
Selecting stop → "View Departures" returns "Failed to load dispatches" error, empty data.
Backend logs: repeated `no_static_departures` for stop IDs, zero realtime/static counts.
Data volume greatly reduced compared to earlier phases.

ROOT CAUSE:
- Stop ID mismatch: client sends integer `sid`, backend expects text `stop_id`
- Possible data loss/filter in GTFS ingestion (only train routes/stops in DB)
- Search endpoint reading from reduced dataset
- Missing dict_stop mapping table (sid ↔ stop_id) breaks departures requests

VALIDATION COMMANDS:
- curl "http://localhost:8000/api/v1/stops/search?q=bus"
- curl "http://localhost:8000/api/v1/stops/29444/departures"
- Backend tests: pytest
- E2E: test_missing_modalities_departures.md

──────────────────────────────────────
File: specs/phase-2-1-fixes-plan.md
──────────────────────────────────────
# Phase 2.1 Fixes Implementation Plan (1-340)

PROBLEM: Phase 2.1 implemented real-time departures, trip details navigation, route categorization.
3 CRITICAL BUGS:
1. Departures show all-day data (past + future) instead of next 10-20 services only
2. Trip navigation loops instead of showing trip details
3. Route list missing 98% of modalities (only Train + Ferry shown, missing Metro/Bus/School Bus/Regional Bus/Light Rail)

ROOT CAUSE ANALYSIS:
1. Backend: Missing time filter in SQL query (WHERE ps.departure_offset_secs >= {current_time_secs})
2. iOS: NavigationLink pattern error (value-based nav creates loop)
3. iOS: RouteType enum only maps standard GTFS types (0-7), missing NSW extended types (401, 700, 712, 714, 900)

DATA VERIFICATION:
- Supabase: 4687 routes, 7 distinct types: {2: 99, 4: 11, 401: 1, 700: 679, 712: 3866, 714: 30, 900: 1}
- Data complete and correct at all layers (GTFS → Supabase → iOS export)
- Bugs are in query logic (backend SQL) or client logic (iOS enum/navigation)

FIX COMPLEXITY: Low-Medium (3 independent fixes, ~55-70 minutes total)

──────────────────────────────────────
File: SydneyTransit/Features/Departures/DeparturesView.swift
──────────────────────────────────────
# DeparturesView.swift (1-238)
[Full SwiftUI code showing infinite scroll departures list with NavigationLink to TripDetailsView]

KEY ELEMENTS:
- Infinite scroll pagination (past/future sentinels)
- NavigationLink(destination: TripDetailsView(tripId:)) for trip navigation
- Stop ID mapping: stop.getStopID() to convert sid → GTFS stop_id for API calls
- Auto-refresh every 30s via viewModel.startAutoRefresh()
- Graceful error handling: "Failed to load departures" if stop_id mapping not found

KNOWN ISSUES (from Phase 2.1 fixes):
- Fixed: Trip navigation loop (now using direct destination pattern)
- Fixed: Sentinel race condition (debounced to 300ms)
- Fixed: 0 minute display bug (improved minutesUntilText logic in Departure model)

──────────────────────────────────────
File: SydneyTransit/Features/Search/SearchView.swift
──────────────────────────────────────
# SearchView.swift (1-135)
[Full SwiftUI code showing FTS5 search with 300ms debounce, results list]

KEY ELEMENTS:
- FTS5 full-text search via DatabaseManager.shared.read { Stop.search(db, query:) }
- 300ms debounce to avoid excessive queries during typing
- NavigationLink to StopDetailsView for each result
- Shows transport mode icon (stop.transportIcon) and stop code
- Error handling: "Search failed" message if database query errors

CURRENT STATE:
- Search works for all modalities IF dict_stop mapping exists and primaryRouteType logic correctly identifies bus/ferry/light rail stops
- Potential issue: If primaryRouteType returns nil for non-train stops, icon defaults to "mappin.circle.fill"

────────────────────────────────────
File: SydneyTransit/Data/Models/Stop.swift
──────────────────────────────────────
# Stop.swift (1-130)
[Full Swift model showing FTS5 search, stop_id lookup via dict_stop table, primaryRouteType computation]

KEY ELEMENTS:
- FTS5 search: JOIN stops_fts, MATCH query, sanitized input
- getStopID(): SELECT stop_id FROM dict_stop WHERE sid = ? (critical for API calls)
- primaryRouteType: queries pattern_stops → patterns → routes, returns most frequent route_type for this stop
- transportIcon: maps route_type to SF Symbol (supports NSW extended types: 401, 700, 712, 714, 900)

KNOWN GAPS:
- primaryRouteType is computed property (queries DB on each access) - may be slow
- Fallback to "mappin.circle.fill" if primaryRouteType is nil (could hide non-train stops if route lookup fails)
- dict_stop mapping critical for getStopID() - if table empty/missing, all departures requests fail

──────────────────────────────────────
File: backend/app/services/realtime_service.py
──────────────────────────────────────
# realtime_service.py (partial, first 200 lines)
[Python code showing get_realtime_departures function: static schedule query → Redis RT delays → merge]

KEY LOGIC:
1. Validate time_secs_local (0-86399) and service_date (YYYY-MM-DD)
2. SQL query: JOIN pattern_stops → patterns → trips → routes → calendar
   - WHERE ps.stop_id = '{stop_id}' AND c.start_date <= '{service_date}' AND ...
   - AND (t.start_time_secs + ps.departure_offset_secs) >= {time_secs_local} (time filter)
   - ORDER BY actual_departure_secs ASC/DESC, LIMIT {expanded_limit}
3. determine_mode(route_id): heuristic to map route_id prefix → mode (sydneytrains, metro, ferries, lightrail, buses)
4. Fetch Redis keys: tu:{mode}:v1 (gzipped JSON blobs with trip delays, platform codes, occupancy)
5. Merge static + RT: realtime_time_secs = scheduled_time_secs + delay_s
6. Sort by realtime_time_secs, return top {limit} departures

KNOWN ISSUES (from issue-144):
- If stop_id is invalid/missing in DB, query returns empty [] → "no_static_departures" log
- Mode heuristic determine_mode() improved (handles MFF, IWLR, SMNW) but uncommitted
- If Redis cache miss, gracefully degrades to static schedules (delay_s=0, realtime=false)

## Excluded Files (over token limit)

Lower-priority files not included to stay under 35k tokens:
- BACKEND_SPECIFICATION.md, DATA_ARCHITECTURE.md, IOS_APP_SPECIFICATION.md (architecture specs - reference in instructions)
- Phase 3-7 plans (deferred features)
- Detailed backend API code (stops.py, gtfs_service.py) - will extrapolate from realtime_service.py patterns
- Trip details/map views (secondary to core departures/search flows)
- GTFS ingestion scripts (scripts/ directory) - data pipeline assumed working based on issue-144 verification

## Summary of Current State

COMPLETED (Phase 0-2.1):
- ✅ GTFS static data pipeline (227MB → Supabase pattern tables → iOS 15-20MB SQLite)
- ✅ iOS offline search (FTS5, all modalities if dict_stop mapping exists)
- ✅ Real-time departures API (Celery poller, Redis cache, static+RT merge)
- ✅ iOS departures screen (infinite scroll, auto-refresh, NavigationLink to trip details)
- ✅ Phase 2.1 fixes: time filtering, trip navigation, route modality enum (7 types: Train/Metro/Bus variants/Ferry/Light Rail)

KNOWN GAPS (from user's problem statement):
1. **Missing complete static data feature set**: No map drawer integration, no comprehensive multi-modal search UI
2. **Incomplete flows**: Search → Stop list → Departures → Map drawer with stop highlights (map drawer may not be fully integrated)
3. **Modal coverage gaps**: Bus/ferry/light rail departures may fail if dict_stop mapping incomplete or primaryRouteType logic broken
4. **Bugs still present**: Issue-144 mentions missing departures for specific stops (29443/29444), suggesting data integrity or ID mapping issues persist

ARCHITECTURE DECISIONS (from 8 Oracle consultations in DATA_ARCHITECTURE.md):
- Pattern model (8-15× compression vs full stop_times)
- Sydney filtering (40-60% reduction via bounding box)
- Adaptive polling (30s GTFS-RT, DST-safe scheduling)
- Redis Lua token bucket rate limiting (4.5 req/s safety margin)
- SQL alert matching (upgrade to Redis index when DB p95 >150ms)
- 3-layer dedup for APNs (DB unique constraint + collapse-id + cooldown)

## Oracle Consultation Request

USER'S TASK (verbatim from transcription):
"Hey, so I want to consult the protocol for implementation roadmap, you see we have put an application built-up in multiple phases. We have done with Kill phase II, but again I don't want to proceed to phase III because this whole planning itself has multiple flaws. But again we can't do anything we already started. So the thing is that by the phase II, we should be able to down the static data in the real-time. Why observe the entire time? We have not really built the comp- if you observe in the static data, we are setting up the page from a map, but we are not building a complete feature set that is directly dependent on the static data. For example, you see 2.0, we came across this, and we have not built user should be able to see search and get all the list of all these drops and everything. Only after we built the complete features that are necessary, once we're done with a static data, only then of course we already built real-time foundations, but we have not integrated that. I don't want to because only after we're done with static data and complete features that is relevant to static data, then we can integrate on top logically. It makes sense to include the real-time foundation and all the options. So now I'm kind of stuck. There's still a lot of bugs relevant to even that. For example, if I go to this specific departure, or any specific stop, when I compare it to our other existing application (official application), a lot of departures were missing. They still currently need to be made sure the static thing is working. Only then we need to move. So now what I need help from the Oracle Consult is to help me design the fate intermediate interfaces between phase I and II. Not only first verify all the existing implementational started things working as expected without any bugs. For example, as I said, there's a lot of depatches were missing from a lot of stops. You need to find out that. Also, we need to handle all the different modalities for the existing features. Also, you need to implement the full feature set of like when I say full features at the UI, the map integration, the core flows. The core flows. When the user comes, we will have a search icon which we currently have. Users will search for any entering a few letters, and then all the different stops (all modal stops) with that character snatch will be shown. And when clicked, we should show all the patches. And you should be able to also see all the patches. When clicked, we should show map on bottom drawer of all the stops. And when clicked on the map, it should highlight that specific stop point. It's like a few other things. Oracle should be given the documentation of what our actual application by the end of the complete implementation should look like. Map to that what all features do we need to implement in this space. Also, very briefly mentioning about how we should do the same thing for the lighter phases as well."

INTERPRETED REQUIREMENTS:
1. **Intermediate phases needed between Phase 1 and Phase 2**: Complete static data features BEFORE integrating real-time
2. **Verify existing implementation**: Fix bugs (missing departures, modal coverage gaps from issue-144)
3. **Full static data feature set**: Search → Stop list (all modalities) → Departures view → Map drawer with stop highlights
4. **Core user flows**: Search (all modal stops) → Tap stop → Show departures + map drawer → Tap map marker → Highlight stop
5. **Map integration**: Bottom drawer showing stop locations on map, tap to highlight
6. **Defer real-time integration**: Only after static data features complete and bug-free
7. **Apply pattern to later phases**: Guidance on refining Phase 3-7 similarly
