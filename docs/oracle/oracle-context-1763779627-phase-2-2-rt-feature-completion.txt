# Oracle Context: Phase 2.2 - Real-Time Feature Completion
# Session: 1763779627-phase-2-2-rt-feature-completion
# Generated: 2025-11-22T01:43:47Z
# Token estimate: ~25,000 tokens

## Repository Structure

prj_transport/
├── backend/
│   ├── app/
│   │   ├── api/v1/
│   │   │   ├── stops.py (370 lines) - Departures endpoint
│   │   │   └── trips.py (148 lines) - Trip details endpoint
│   │   ├── services/
│   │   │   ├── realtime_service.py (412 lines) - RT merge logic
│   │   │   └── trip_service.py (201 lines) - Trip queries
│   │   ├── tasks/
│   │   │   ├── celery_app.py (133 lines) - 3 queues, Beat config
│   │   │   └── gtfs_rt_poller.py (311 lines) - GTFS-RT polling (TU, VP only)
│   │   ├── models/
│   │   │   ├── stops.py - Pydantic models
│   │   │   └── trips.py - Pydantic models
│   │   └── config.py
│   └── requirements.txt
├── SydneyTransit/
│   ├── Data/
│   │   ├── Models/
│   │   │   ├── Departure.swift (154 lines) - RT departure model
│   │   │   └── Trip.swift (98 lines) - Trip with stops
│   │   └── Repositories/
│   │       ├── DeparturesRepository.swift (89 lines)
│   │       └── TripRepository.swift (67 lines)
│   ├── Features/
│   │   ├── Departures/
│   │   │   ├── DeparturesViewModel.swift (210 lines) - 30s auto-refresh
│   │   │   └── DeparturesView.swift (145 lines)
│   │   └── Trips/
│   │       ├── TripDetailsViewModel.swift (88 lines)
│   │       └── TripDetailsView.swift (112 lines)
│   └── Core/Network/APIClient.swift (182 lines)
├── .phase-logs/
│   ├── phase-2/REPORT.md (228 lines) - Phase 2 completion status
│   └── phase-2-1-feature-completion/REPORT.md (210 lines) - Phase 2.1 status
├── oracle/
│   └── specs/ (original architecture specs missing from context)
└── CLAUDE.md (project instructions)

## File Contents

──────────────────────────────────────
File: backend/app/services/realtime_service.py
──────────────────────────────────────
"""Real-Time Departures Service - Checkpoint 4.

Merges static schedules from Supabase with Redis GTFS-RT delays.
Service returns departures with delay_s, realtime flag, graceful degradation.

Architecture:
- Step 1: Fetch static schedules from Supabase (pattern model query)
- Step 2: Determine modes from route IDs (heuristic)
- Step 3: Fetch Redis RT delays (gzip blobs per mode)
- Step 4: Merge static + RT, sort by realtime_time_secs

Graceful degradation:
- Redis miss or gzip error → delay_s=0, realtime=false (static fallback)
- Trip ID mismatch → delay_s=0 (static schedule)
"""

import gzip
import json
import time
import redis
from typing import Optional, List, Dict, Set

from app.db.supabase_client import get_supabase
from app.config import settings
from app.utils.logging import get_logger

logger = get_logger(__name__)

# Redis client for binary blobs (gzipped data)
_redis_binary_client: Optional[redis.Redis] = None

def get_redis_binary() -> redis.Redis:
    """Get Redis client for binary blob operations (gzipped data)."""
    global _redis_binary_client
    if _redis_binary_client is None:
        _redis_binary_client = redis.from_url(
            settings.REDIS_URL,
            decode_responses=False,
            max_connections=10
        )
    return _redis_binary_client

def determine_mode(route_id: str) -> str:
    """Determine transport mode from route ID prefix.

    Heuristic based on NSW GTFS route_id patterns:
    - T*, BMT* → sydneytrains
    - M* (except MFF) → metro
    - MFF → ferries (Manly Fast Ferry)
    - F*, 9-F* → ferries
    - L*, IWLR* → lightrail
    - else → buses
    """
    if not route_id:
        return "buses"

    route_id_upper = route_id.upper()

    if route_id_upper == 'MFF':
        return 'ferries'
    elif route_id_upper.startswith('T') or route_id_upper.startswith('BMT'):
        return 'sydneytrains'
    elif route_id_upper.startswith('M') or route_id_upper.startswith('SMNW'):
        return 'metro'
    elif route_id_upper.startswith('F') or route_id_upper.startswith('9-F'):
        return 'ferries'
    elif route_id_upper.startswith('L') or route_id_upper.startswith('IWLR'):
        return 'lightrail'
    else:
        return 'buses'

def get_realtime_departures(
    stop_id: str,
    time_secs_local: Optional[int] = None,
    service_date: Optional[str] = None,
    direction: str = "future",
    limit: int = 10,
) -> List[Dict]:
    """Get real-time departures for a stop (merges static schedules + GTFS-RT delays).

    Args:
        stop_id: GTFS stop_id
        time_secs_local: Seconds since local (Sydney) midnight for filtering
        service_date: Service date in YYYY-MM-DD (Sydney time)
        direction: 'past' for earlier departures, 'future' for later
        limit: Max departures to return

    Returns:
        List of departure dicts with fields:
        - trip_id, route_short_name/long_name/type/color, headsign
        - scheduled_time_secs, realtime_time_secs, delay_s, realtime, stop_sequence
        - platform, wheelchair_accessible, occupancy_status (0-8 or None)
    """
    start_time = time.time()

    try:
        supabase = get_supabase()
        redis_binary = get_redis_binary()

        # Backwards compatibility: derive time/date using Sydney timezone if missing
        if service_date is None or time_secs_local is None:
            import pytz
            from datetime import datetime

            sydney_tz = pytz.timezone('Australia/Sydney')
            now_dt = datetime.now(sydney_tz)
            service_date = now_dt.strftime("%Y-%m-%d") if service_date is None else service_date
            if time_secs_local is None:
                midnight = now_dt.replace(hour=0, minute=0, second=0, microsecond=0)
                time_secs_local = int((now_dt - midnight).total_seconds())

        # Guard against invalid time inputs
        if time_secs_local is None or not (0 <= time_secs_local < 86400):
            raise ValueError("Invalid time_secs_local; must be 0-86399 seconds since local midnight")
        if not service_date:
            raise ValueError("service_date is required")

        logger.info(
            "departures_lookup_start",
            stop_id=stop_id,
            stop_id_type=type(stop_id).__name__,
            service_date=service_date,
            time_secs_local=time_secs_local
        )

        # Step 1: Fetch static schedules (phase 1 query)
        time_filter = f">= {time_secs_local}" if direction == "future" else f"<= {time_secs_local}"
        sort_order = "ASC" if direction == "future" else "DESC"

        # Expand SQL LIMIT to capture delayed trains outside user window
        expanded_limit = max(limit * 3, 30)

        query = f"""
        SELECT
            t.trip_id,
            t.trip_headsign,
            t.direction_id,
            t.wheelchair_accessible,
            t.start_time_secs,
            r.route_id,
            r.route_short_name,
            r.route_long_name,
            r.route_type,
            r.route_color,
            ps.departure_offset_secs,
            ps.stop_sequence,
            (t.start_time_secs + ps.departure_offset_secs) as actual_departure_secs
        FROM pattern_stops ps
        JOIN patterns p ON ps.pattern_id = p.pattern_id
        JOIN trips t ON t.pattern_id = p.pattern_id
        JOIN routes r ON t.route_id = r.route_id
        JOIN calendar c ON t.service_id = c.service_id
        WHERE ps.stop_id = '{stop_id}'
          AND c.start_date <= '{service_date}'
          AND c.end_date >= '{service_date}'
          AND (t.start_time_secs + ps.departure_offset_secs) {time_filter}
        ORDER BY (t.start_time_secs + ps.departure_offset_secs) {sort_order}
        LIMIT {expanded_limit}
        """

        result = supabase.rpc("exec_raw_sql", {"query": query}).execute()
        static_deps = result.data or []

        if not static_deps:
            logger.warning(
                "no_static_departures",
                stop_id=stop_id,
                service_date=service_date,
                time_secs=time_secs_local
            )
            return []

        # Step 2: Determine modes needed (heuristic from route_ids)
        modes_needed: Set[str] = {determine_mode(dep['route_id']) for dep in static_deps}

        # Step 3: Fetch Redis RT delays + platform codes + occupancy (gzip blobs per mode)
        trip_delays: Dict[str, int] = {}
        trip_platforms: Dict[str, str] = {}
        trip_occupancy: Dict[str, int] = {}

        for mode in modes_needed:
            try:
                # Fetch TripUpdates for delays
                tu_key = f'tu:{mode}:v1'
                tu_blob = redis_binary.get(tu_key)

                if tu_blob:
                    decompressed = gzip.decompress(tu_blob)
                    data = json.loads(decompressed)

                    for tu in data:
                        trip_id = tu.get('trip_id')
                        delay_s = tu.get('delay_s', 0)
                        if trip_id:
                            trip_delays[trip_id] = delay_s

                            # Extract platform from stop_time_update
                            stop_time_updates = tu.get('stop_time_updates', [])
                            for stu in stop_time_updates:
                                if stu.get('stop_id') == stop_id and stu.get('platform_code'):
                                    trip_platforms[trip_id] = stu['platform_code']
                                    break

                    logger.debug("trip_updates_fetched", mode=mode, trip_count=len(data))
                else:
                    logger.debug("trip_updates_miss", mode=mode, key=tu_key)

                # Fetch VehiclePositions for occupancy
                vp_key = f'vp:{mode}:v1'
                vp_blob = redis_binary.get(vp_key)

                if vp_blob:
                    decompressed = gzip.decompress(vp_blob)
                    vp_data = json.loads(decompressed)

                    for vp in vp_data:
                        trip_id = vp.get('trip_id')
                        occupancy_status = vp.get('occupancy_status')
                        if trip_id and occupancy_status is not None:
                            trip_occupancy[trip_id] = occupancy_status

                    logger.debug("vehicle_positions_fetched", mode=mode, vehicle_count=len(vp_data))
                else:
                    logger.debug("vehicle_positions_miss", mode=mode, key=vp_key)

            except gzip.BadGzipFile:
                logger.warning("realtime_gzip_error", mode=mode)
            except json.JSONDecodeError as exc:
                logger.warning("realtime_json_error", mode=mode, error=str(exc))
            except Exception as exc:
                logger.warning("realtime_fetch_failed", mode=mode, error=str(exc))

        # Step 4: Merge static + RT
        departures = []

        for dep in static_deps:
            trip_id = dep['trip_id']
            scheduled_time_secs = dep['actual_departure_secs']
            delay_s = trip_delays.get(trip_id, 0)
            realtime_time_secs = scheduled_time_secs + delay_s
            platform = trip_platforms.get(trip_id)
            occupancy_status = trip_occupancy.get(trip_id)
            wheelchair_accessible = dep.get('wheelchair_accessible', 0)

            departures.append({
                'trip_id': trip_id,
                'route_short_name': dep['route_short_name'],
                'route_long_name': dep['route_long_name'],
                'route_type': dep['route_type'],
                'route_color': dep.get('route_color'),
                'headsign': dep['trip_headsign'],
                'scheduled_time_secs': scheduled_time_secs,
                'realtime_time_secs': realtime_time_secs,
                'delay_s': delay_s,
                'realtime': delay_s != 0,
                'stop_sequence': dep['stop_sequence'],
                'platform': platform,
                'wheelchair_accessible': wheelchair_accessible,
                'occupancy_status': occupancy_status,
            })

        # Sort by realtime departure time
        departures.sort(key=lambda x: x['realtime_time_secs'], reverse=(direction == "past"))

        # Trim to user-requested limit (after RT merge and sort)
        departures = departures[:limit]

        # Count realtime vs static
        realtime_count = sum(1 for d in departures if d['realtime'])
        static_count = len(departures) - realtime_count

        duration_ms = int((time.time() - start_time) * 1000)
        logger.info(
            "realtime_departures_fetched",
            stop_id=stop_id,
            service_date=service_date,
            time_secs=time_secs_local,
            total_count=len(departures),
            realtime_count=realtime_count,
            static_count=static_count,
            modes=list(modes_needed),
            duration_ms=duration_ms
        )

        return departures

    except Exception as exc:
        duration_ms = int((time.time() - start_time) * 1000)
        logger.error(
            "realtime_departures_failed",
            stop_id=stop_id,
            service_date=service_date,
            time_secs=time_secs_local,
            error=str(exc),
            duration_ms=duration_ms
        )
        raise

──────────────────────────────────────
File: backend/app/tasks/gtfs_rt_poller.py
──────────────────────────────────────
"""GTFS-RT Poller Task - Checkpoint 2.

Polls NSW Transport API every 30s for 5 modes × 2 feeds (VehiclePositions + TripUpdates).
Caches gzipped JSON blobs in Redis with 75s/90s TTL.

NOTE: ServiceAlerts feed NOT currently implemented (only TU and VP).

Architecture:
- Redis SETNX lock for idempotency
- Gzip compression (~70% blob size reduction)
- Sequential fetch with per-mode timeout handling
- Structured logging (no full protobuf dumps)

Modes:
- buses, sydneytrains, metro, ferries, lightrail
- 10 API calls per poll (5 modes × 2 feeds each)
"""

import gzip
import json
import time
from typing import Optional

import redis
import requests
from google.transit import gtfs_realtime_pb2
from celery.exceptions import SoftTimeLimitExceeded

from app.tasks.celery_app import app as celery_app
from app.config import settings
from app.utils.logging import get_logger

logger = get_logger(__name__)

NSW_BASE_URL = "https://api.transport.nsw.gov.au"
NSW_API_KEY = settings.NSW_API_KEY
REQUEST_TIMEOUT = 8

MODES_CONFIG = {
    "buses": {
        "vehiclepos_path": "/v1/gtfs/vehiclepos/buses",
        "realtime_path": "/v1/gtfs/realtime/buses",
    },
    "sydneytrains": {
        "vehiclepos_path": "/v2/gtfs/vehiclepos/sydneytrains",
        "realtime_path": "/v2/gtfs/realtime/sydneytrains",
    },
    "metro": {
        "vehiclepos_path": "/v2/gtfs/vehiclepos/metro",
        "realtime_path": "/v2/gtfs/realtime/metro",
    },
    "ferries": {
        "vehiclepos_path": "/v1/gtfs/vehiclepos/ferries/sydneyferries",
        "realtime_path": "/v1/gtfs/realtime/ferries/sydneyferries",
    },
    "lightrail": {
        "vehiclepos_path": "/v1/gtfs/vehiclepos/lightrail",
        "realtime_path": "/v1/gtfs/realtime/lightrail",
    },
}

_redis_client: Optional[redis.Redis] = None

def get_redis_client() -> redis.Redis:
    """Get singleton Redis client."""
    global _redis_client
    if _redis_client is None:
        _redis_client = redis.from_url(settings.REDIS_URL, decode_responses=False)
    return _redis_client

def fetch_gtfs_rt(mode: str, feed_type: str) -> Optional[bytes]:
    """Fetch GTFS-RT feed from NSW API."""
    path_key = f"{feed_type}_path"
    if mode not in MODES_CONFIG or path_key not in MODES_CONFIG[mode]:
        logger.error("invalid_mode_or_feed", mode=mode, feed_type=feed_type)
        return None

    path = MODES_CONFIG[mode][path_key]
    url = f"{NSW_BASE_URL}{path}"
    headers = {
        "Authorization": f"apikey {NSW_API_KEY}",
        "Accept": "application/x-google-protobuf",
    }

    try:
        response = requests.get(url, headers=headers, timeout=REQUEST_TIMEOUT)
        response.raise_for_status()
        return response.content
    except requests.Timeout:
        logger.warning("nsw_api_timeout", mode=mode, feed_type=feed_type, url=path)
        return None
    except requests.HTTPError as exc:
        status_code = exc.response.status_code if exc.response else 0
        if status_code == 429:
            logger.error("nsw_api_rate_limit", mode=mode, feed_type=feed_type, url=path)
        elif status_code == 503:
            logger.warning("nsw_api_unavailable", mode=mode, feed_type=feed_type, url=path)
        else:
            logger.error("nsw_api_http_error", mode=mode, feed_type=feed_type, status_code=status_code, url=path)
        return None
    except Exception as exc:
        logger.error("nsw_api_error", mode=mode, feed_type=feed_type, error=str(exc), url=path)
        return None

def parse_vehicle_positions(pb_data: bytes) -> list[dict]:
    """Parse VehiclePositions protobuf into JSON-serializable dicts."""
    try:
        feed = gtfs_realtime_pb2.FeedMessage()
        feed.ParseFromString(pb_data)

        vehicles = []
        for entity in feed.entity:
            if not entity.HasField("vehicle"):
                continue

            vehicle = entity.vehicle
            occupancy_status = None
            if vehicle.HasField("occupancy_status"):
                occupancy_status = vehicle.occupancy_status

            vehicle_data = {
                "vehicle_id": vehicle.vehicle.id if vehicle.HasField("vehicle") else None,
                "trip_id": vehicle.trip.trip_id if vehicle.HasField("trip") else None,
                "route_id": vehicle.trip.route_id if vehicle.HasField("trip") else None,
                "lat": vehicle.position.latitude if vehicle.HasField("position") else None,
                "lon": vehicle.position.longitude if vehicle.HasField("position") else None,
                "bearing": vehicle.position.bearing if vehicle.HasField("position") and vehicle.position.HasField("bearing") else None,
                "speed": vehicle.position.speed if vehicle.HasField("position") and vehicle.position.HasField("speed") else None,
                "timestamp": vehicle.timestamp if vehicle.HasField("timestamp") else None,
                "occupancy_status": occupancy_status,
            }
            vehicles.append(vehicle_data)

        return vehicles
    except Exception as exc:
        logger.error("parse_vehicle_positions_error", error=str(exc))
        return []

def parse_trip_updates(pb_data: bytes) -> list[dict]:
    """Parse TripUpdates protobuf into JSON-serializable dicts."""
    try:
        feed = gtfs_realtime_pb2.FeedMessage()
        feed.ParseFromString(pb_data)

        trip_updates = []
        for entity in feed.entity:
            if not entity.HasField("trip_update"):
                continue

            trip_update = entity.trip_update

            stop_time_updates = []
            for stu in trip_update.stop_time_update:
                stop_update = {
                    "stop_id": stu.stop_id if stu.HasField("stop_id") else None,
                    "arrival_delay": stu.arrival.delay if stu.HasField("arrival") and stu.arrival.HasField("delay") else None,
                    "departure_delay": stu.departure.delay if stu.HasField("departure") and stu.departure.HasField("delay") else None,
                }
                stop_time_updates.append(stop_update)

            trip_data = {
                "trip_id": trip_update.trip.trip_id if trip_update.HasField("trip") else None,
                "route_id": trip_update.trip.route_id if trip_update.HasField("trip") else None,
                "delay_s": trip_update.delay if trip_update.HasField("delay") else 0,
                "stop_time_updates": stop_time_updates,
            }
            trip_updates.append(trip_data)

        return trip_updates
    except Exception as exc:
        logger.error("parse_trip_updates_error", error=str(exc))
        return []

def cache_blob(redis_client: redis.Redis, key: str, data: list, ttl: int) -> bool:
    """Cache gzipped JSON blob in Redis."""
    try:
        json_data = json.dumps(data).encode("utf-8")
        compressed = gzip.compress(json_data)
        redis_client.set(key, compressed, ex=ttl)
        return True
    except Exception as exc:
        logger.error("cache_blob_error", key=key, error=str(exc))
        return False

@celery_app.task(
    name="app.tasks.gtfs_rt_poller.poll_gtfs_rt",
    queue="critical",
    bind=True,
    max_retries=0,
    time_limit=15,
    soft_time_limit=10,
)
def poll_gtfs_rt(self):
    """Poll NSW GTFS-RT feeds for all modes (TU and VP only, NO ServiceAlerts).

    Cache keys:
    - vp:{mode}:v1 (TTL 75s)
    - tu:{mode}:v1 (TTL 90s)
    """
    start_time = time.time()
    redis_client = get_redis_client()

    # Singleton lock (30s TTL)
    lock_key = "lock:poll_gtfs_rt"
    lock_acquired = redis_client.set(lock_key, "1", nx=True, ex=30)

    if not lock_acquired:
        logger.info("poll_gtfs_rt_skipped", reason="already_running")
        return

    try:
        logger.info("poll_gtfs_rt_started", timestamp=int(start_time))

        vp_count = 0
        tu_count = 0
        modes = list(MODES_CONFIG.keys())

        for mode in modes:
            # Fetch VehiclePositions
            vp_data = fetch_gtfs_rt(mode, "vehiclepos")
            if vp_data:
                parsed_vp = parse_vehicle_positions(vp_data)
                if parsed_vp:
                    cache_key = f"vp:{mode}:v1"
                    if cache_blob(redis_client, cache_key, parsed_vp, ttl=75):
                        vp_count += len(parsed_vp)
                        logger.debug("vp_cached", mode=mode, count=len(parsed_vp), key=cache_key)

            # Fetch TripUpdates
            tu_data = fetch_gtfs_rt(mode, "realtime")
            if tu_data:
                parsed_tu = parse_trip_updates(tu_data)
                if parsed_tu:
                    cache_key = f"tu:{mode}:v1"
                    if cache_blob(redis_client, cache_key, parsed_tu, ttl=90):
                        tu_count += len(parsed_tu)
                        logger.debug("tu_cached", mode=mode, count=len(parsed_tu), key=cache_key)

        duration_ms = int((time.time() - start_time) * 1000)
        logger.info(
            "poll_gtfs_rt_complete",
            modes=modes,
            duration_ms=duration_ms,
            vp_count=vp_count,
            tu_count=tu_count,
        )

    except SoftTimeLimitExceeded:
        logger.warning("poll_gtfs_rt_soft_timeout", duration_ms=int((time.time() - start_time) * 1000))
    except Exception as exc:
        logger.error("poll_gtfs_rt_error", error=str(exc), duration_ms=int((time.time() - start_time) * 1000))
    finally:
        redis_client.delete(lock_key)

──────────────────────────────────────
File: SydneyTransit/SydneyTransit/Data/Models/Departure.swift
──────────────────────────────────────
import Foundation
import SwiftUI

struct Departure: Codable, Identifiable, Hashable {
    let tripId: String
    let routeShortName: String
    let headsign: String
    let scheduledTimeSecs: Int
    let realtimeTimeSecs: Int
    let delayS: Int
    let realtime: Bool
    let platform: String?
    let wheelchairAccessible: Int
    let occupancy_status: Int?

    var id: String { "\(tripId)_\(scheduledTimeSecs)" }

    // CURRENT IMPLEMENTATION: Simple countdown + delay text
    // MISSING: Color-coded badges (green early, orange/red late, purple estimated)

    var minutesUntil: Int {
        let secsRemaining = realtimeTimeSecs - currentSydneySecondsSinceMidnight
        return max(0, secsRemaining / 60)
    }

    var minutesUntilText: String {
        let secsRemaining = realtimeTimeSecs - currentSydneySecondsSinceMidnight
        if secsRemaining < -59 {
            let minsAgo = (abs(secsRemaining) + 30) / 60
            return "\(minsAgo) min ago"
        } else if secsRemaining < 0 {
            return "Now"
        } else {
            let mins = max(1, Int(ceil(Double(secsRemaining) / 60.0)))
            return "\(mins) min"
        }
    }

    private var currentSydneySecondsSinceMidnight: Int {
        let sydney = TimeZone(identifier: "Australia/Sydney")!
        let now = Date()
        var calendar = Calendar.current
        calendar.timeZone = sydney
        let midnight = calendar.startOfDay(for: now)
        return Int(now.timeIntervalSince(midnight))
    }

    var delayText: String? {
        guard delayS > 0 else { return nil }
        let mins = delayS / 60
        return "+\(mins) min"
    }

    var departureTime: String {
        let mins = realtimeTimeSecs / 60
        let hours = mins / 60
        let remainingMins = mins % 60
        return String(format: "%02d:%02d", hours, remainingMins)
    }

    // Occupancy icon (existing implementation)
    var occupancyIcon: (symbolName: String, color: Color, label: String)? {
        guard let status = occupancy_status else { return nil }

        switch status {
        case 0...1:
            return ("figure.stand", .green, "Low occupancy")
        case 2:
            return ("figure.stand.line.dotted.figure.stand", .yellow, "Moderate occupancy")
        case 3...4:
            return ("figure.stand.line.dotted.figure.stand", .orange, "High occupancy")
        case 5...6:
            return ("figure.stand.line.dotted.figure.stand", .red, "Very crowded")
        default:
            return nil
        }
    }

    enum CodingKeys: String, CodingKey {
        case tripId = "trip_id"
        case routeShortName = "route_short_name"
        case headsign
        case scheduledTimeSecs = "scheduled_time_secs"
        case realtimeTimeSecs = "realtime_time_secs"
        case delayS = "delay_s"
        case realtime
        case platform
        case wheelchairAccessible = "wheelchair_accessible"
        case occupancy_status = "occupancy_status"
    }

    // Graceful decoding to handle missing/null fields
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        tripId = try container.decodeIfPresent(String.self, forKey: .tripId) ?? ""
        routeShortName = try container.decodeIfPresent(String.self, forKey: .routeShortName) ?? ""
        headsign = try container.decodeIfPresent(String.self, forKey: .headsign) ?? ""

        let scheduled = try container.decodeIfPresent(Int.self, forKey: .scheduledTimeSecs) ?? 0
        scheduledTimeSecs = scheduled
        realtimeTimeSecs = try container.decodeIfPresent(Int.self, forKey: .realtimeTimeSecs) ?? scheduled
        delayS = try container.decodeIfPresent(Int.self, forKey: .delayS) ?? 0
        realtime = try container.decodeIfPresent(Bool.self, forKey: .realtime) ?? (delayS != 0)

        // Platform can be string or int, normalize to String?
        if let platformString = try container.decodeIfPresent(String.self, forKey: .platform) {
            platform = platformString
        } else if let platformInt = try? container.decodeIfPresent(Int.self, forKey: .platform) {
            platform = String(platformInt)
        } else {
            platform = nil
        }

        wheelchairAccessible = try container.decodeIfPresent(Int.self, forKey: .wheelchairAccessible) ?? 0
        occupancy_status = try container.decodeIfPresent(Int.self, forKey: .occupancy_status)
    }
}

──────────────────────────────────────
File: SydneyTransit/SydneyTransit/Data/Models/Trip.swift
──────────────────────────────────────
import Foundation

struct Trip: Codable, Identifiable {
    let tripId: String
    let headsign: String
    let routeShortName: String
    let routeColor: String?
    let stops: [TripStop]

    var id: String { tripId }

    enum CodingKeys: String, CodingKey {
        case tripId = "trip_id"
        case headsign
        case routeShortName = "route_short_name"
        case routeColor = "route_color"
        case stops
    }
}

struct TripStop: Codable, Identifiable {
    let stopId: String
    let stopName: String
    let arrivalTime: Int  // Seconds since midnight
    let platform: String?
    let wheelchairAccessible: Int

    // MISSING: Real-time delay fields (delay_s, realtime_arrival_time, realtime flag)
    // Current implementation shows ONLY scheduled arrival times

    var id: String { stopId }

    var formattedArrivalTime: String {
        let mins = arrivalTime / 60
        let hours = mins / 60
        let remainingMins = mins % 60
        return String(format: "%02d:%02d", hours, remainingMins)
    }

    enum CodingKeys: String, CodingKey {
        case stopId = "stop_id"
        case stopName = "stop_name"
        case arrivalTime = "arrival_time"
        case platform
        case wheelchairAccessible = "wheelchair_accessible"
    }
}

──────────────────────────────────────
File: .phase-logs/phase-2/REPORT.md
──────────────────────────────────────
# Phase 2 Implementation Report

**Status:** Complete (User Testing Required)
**Duration:** ~3 hours
**Checkpoints:** 8 of 10 implemented, 2 testing checklists

## Implementation Summary

**Backend:**
- Celery app: 3 queues (critical/normal/batch), Beat scheduler, DST-safe timezone
- GTFS-RT poller: 5 modes × 2 feeds (VehiclePositions + TripUpdates ONLY, NO ServiceAlerts)
- Worker scripts: start_worker_critical.sh, start_worker_service.sh, start_beat.sh
- RT departures service: merges static schedules + Redis delays
- Stops API updated: returns realtime: true for delayed trips

**iOS:**
- Departure model: countdown logic, delay text, departure time formatting
- APIClient: URLSession timeout config (8s request, 15s resource)
- DeparturesRepository: protocol-based, fetches from API
- DeparturesViewModel: @MainActor, Timer auto-refresh (30s)
- DeparturesView: SwiftUI List, DepartureRow with delay badges

**Integration:**
- Backend polls NSW API every 30s → Redis cache (vp:{mode}:v1, tu:{mode}:v1)
- iOS calls API → API enriches static schedules with Redis RT delays
- Auto-refresh: iOS Timer (30s) synchronizes with backend polling

## Checkpoints

(Checkpoints 1-8 completed successfully - see full report for details)

### Checkpoint 9: Integration Test
- Status: ⏳ User Testing Required

### Checkpoint 10: Graceful Degradation Test
- Status: ⏳ User Testing Required

## Acceptance Criteria

- [x] Backend: Celery worker starts without import errors
- [x] Backend: Beat schedules poll_gtfs_rt every 30s
- [ ] Backend: Redis has 10 keys after 30s (vp:*, tu:*) — User Testing
- [ ] Backend: Redis keys have TTL 60-90s — User Testing
- [ ] Backend: GET /stops/{id}/departures returns realtime: true — User Testing
- [x] iOS: DeparturesView shows list of departures
- [ ] iOS: Countdown updates after 30s auto-refresh — User Testing
- [x] iOS: Delay badges show orange when delay_s > 0
- [x] iOS: Pull-to-refresh triggers network call

**Result: 8/14 passed (automated), 6/14 require user testing**

## Files Changed

**Backend:**
- Created: celery_app.py, gtfs_rt_poller.py, realtime_service.py, worker scripts
- Modified: stops.py, requirements.txt

**iOS:**
- Created: Departure.swift, APIClient.swift, DeparturesRepository.swift, DeparturesViewModel.swift, DeparturesView.swift

**Total:** ~2,300+ lines added

## Known Issues

None (pending user testing validation)

## Critical Notes

**Worker Start Order:**
1. Terminal 1: Backend (uvicorn)
2. Terminal 2: Worker (critical queue)
3. Terminal 3: Beat (scheduler)
4. Wait 30s for first Redis cache before testing iOS

**Monitoring:**
```bash
redis-cli KEYS vp:* tu:*
redis-cli TTL vp:buses:v1
```

──────────────────────────────────────
File: .phase-logs/phase-2-1-feature-completion/REPORT.md
──────────────────────────────────────
# Phase 2.1 Implementation Report

**Status:** Complete
**Duration:** ~2 hours
**Checkpoints:** 5 of 5 completed

## Implementation Summary

**Backend:**
- Trip details API endpoint (GET /trips/{trip_id})
- Pattern model queries (trips→patterns→pattern_stops→stops join)
- GTFS-RT merge for real-time arrivals (NOT IMPLEMENTED - returns only scheduled times)
- Platform/wheelchair fields in departures API

**iOS:**
- Stop search icons (SF Symbols with VoiceOver)
- Real departures integration (NavigationLink from StopDetailsView)
- Trip details view (intermediary stops with arrival times - SCHEDULED ONLY)
- Route list modality filter (segmented control)
- A-Z alphabetical index navigation (iOS 26+)

## Checkpoints

### Checkpoint 1: Stop Search Icon Enhancement ✅
### Checkpoint 2: Real Departures Integration ✅
### Checkpoint 3: Trip Details View Implementation ✅
(NOTE: Backend trip_service.py has placeholder comment for GTFS-RT merge, not implemented)

### Checkpoint 4: Route List Modality Filter ✅
### Checkpoint 5: Alphabetical Index Navigation ✅

## Acceptance Criteria

- ✅ Stop search results show transport mode icon
- ✅ Tapping stop shows StopDetailsView with "View Departures" button
- ✅ Tapping "View Departures" shows real API data
- ✅ Each departure row shows delay badge, platform, wheelchair icon
- ✅ Tapping departure shows TripDetailsView with intermediary stops + arrival times
- ✅ Route list has modality segmented control
- ✅ A-Z alphabetical index (iOS 26+)

**Result: 10/10 passed**

## Known Issues

1. **iOS Trip feature files need manual Xcode references**
2. **Platform data may be unavailable** (NSW API may not provide platform_code)
3. **iOS 26+ requirement for A-Z index**
4. **Trip intermediary stops show SCHEDULED times only** (GTFS-RT merge not implemented)

## Ready for Merge

**Status:** Yes

---

## PROJECT SUMMARY (Current State)

**What Works:**
- Departure list shows RT delays (delay_s, realtime flag)
- 30s auto-refresh updates departures
- Occupancy icons displayed
- Wheelchair accessibility shown
- Platform info (when available from GTFS-RT)
- Trip details view shows intermediary stops (SCHEDULED times only)

**What's Missing (Phase 2.2 Scope):**
1. **ServiceAlerts:** Not parsed in poller, no API endpoint, no iOS display
2. **RT Delays for Trip Intermediary Stops:** Trip details view shows scheduled times only (no RT merge)
3. **Color-Coded Delay Badges:** Current badges are simple orange for late, no green (early), red (very late), purple (estimated)
4. **Centralized RT Architecture:** realtime_service.py works but no clear schema docs, some duplication potential
5. **Documentation:** No RealTimeFeatures.md guide, no RealTimeDataModels.md schema reference

**API Call Budget (Current):**
- TU + VP: 10 calls/poll × 2,880 polls/day = 28,800 calls/day
- Adding ServiceAlerts: +5 calls/poll = 43,200 calls/day (still <60K limit ✅)

**Redis Keys (Current):**
- 10 keys: tu:{mode}:v1, vp:{mode}:v1 (5 modes each)
- Adding ServiceAlerts: +5 keys (sa:{mode}:v1) = 15 keys total

**Architecture Alignment:**
- ✅ Per-mode blobs (DATA_ARCHITECTURE.md)
- ✅ Gzip compression (~70% reduction)
- ✅ Singleton poller (Redis SETNX lock)
- ✅ Graceful degradation (Redis miss → static schedules)
- ✅ Structured logging (structlog JSON)
- ✅ API envelope format (INTEGRATION_CONTRACTS.md)
- ✅ MVVM pattern (IOS_APP_SPECIFICATION.md)
- ✅ Protocol-based repositories
- ✅ @MainActor ViewModels

**Next Phase Requirement:**
- Complete all real-time features before Phase 3 (user auth)
- Follow Phase 1.2 / 2.1 checkpoint pattern (design → implement → validate → commit/tag)
- Maintain solo-dev principles (simplicity, self-healing, clear docs)
